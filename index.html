<!DOCTYPE html>
<html lang="es">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>Astrología Científica - izarren.top</title>
    <link rel="stylesheet" href="https://cdn.jsdelivr.net/npm/bootstrap@5.2.3/dist/css/bootstrap.min.css">
    <style>
        body {
            font-family: 'Segoe UI', Arial, sans-serif;
            background-color: #f0f0f0;
            margin: 0;
            padding: 20px;
            color: #333;
        }
        .container {
            max-width: 1200px;
            margin: 0 auto;
        }
        .chart-container {
            background-color: white;
            border-radius: 10px;
            box-shadow: 0 4px 8px rgba(0, 0, 0, 0.1);
            padding: 20px;
            margin-bottom: 20px;
        }
        .controls-container {
            background-color: white;
            border-radius: 10px;
            box-shadow: 0 4px 8px rgba(0, 0, 0, 0.1);
            padding: 20px;
            margin-bottom: 20px;
        }
        .info-container {
            background-color: white;
            border-radius: 10px;
            box-shadow: 0 4px 8px rgba(0, 0, 0, 0.1);
            padding: 20px;
            margin-bottom: 20px;
            max-height: 600px;
            overflow-y: auto;
        }
        .coincidencias-container {
            background-color: white;
            border-radius: 10px;
            box-shadow: 0 4px 8px rgba(0, 0, 0, 0.1);
            padding: 20px;
            margin-bottom: 20px;
            max-height: 600px;
            overflow-y: auto;
        }
        .wheel-container {
            position: relative;
            width: 100%;
            max-width: 800px;
            height: auto;
            aspect-ratio: 1/1;
            margin: 0 auto;
        }
        .chart-svg {
            width: 100%;
            height: 100%;
        }
        .planet-symbol {
            font-weight: bold;
            cursor: pointer;
        }
        .aspect-line {
            cursor: pointer;
        }
        .hidden {
            display: none;
        }
        .year-container {
            margin-bottom: 10px;
            border: 1px solid #ddd;
            border-radius: 5px;
            overflow: hidden;
        }
        .year-header {
            background-color: #f8f9fa;
            padding: 10px 15px;
            cursor: pointer;
            display: flex;
            justify-content: space-between;
            align-items: center;
        }
        .year-content {
            padding: 15px;
            display: none;
        }
        .expanded {
            display: block;
        }
        .coincidence-date {
            margin: 5px 0;
            padding: 8px;
            border-radius: 4px;
            background-color: #f1f1f1;
            display: flex;
            justify-content: space-between;
            align-items: center;
        }
        .coincidence-date:hover {
            background-color: #e9e9e9;
        }
        .planet-btn {
            margin-right: 5px;
            border-radius: 50%;
            width: 30px;
            height: 30px;
            display: inline-flex;
            align-items: center;
            justify-content: center;
            font-weight: bold;
            color: white;
            border: none;
            cursor: pointer;
        }
        .tooltip-custom {
            position: absolute;
            padding: 10px;
            background-color: rgba(0, 0, 0, 0.7);
            color: white;
            border-radius: 5px;
            font-size: 14px;
            pointer-events: none;
            z-index: 1000;
        }
        .tab-content {
            padding: 15px;
        }
        .loading {
            position: fixed;
            top: 0;
            left: 0;
            width: 100%;
            height: 100%;
            background-color: rgba(255, 255, 255, 0.7);
            display: flex;
            justify-content: center;
            align-items: center;
            z-index: 9999;
        }
        .loading-spinner {
            width: 50px;
            height: 50px;
            border: 5px solid #f3f3f3;
            border-top: 5px solid #3498db;
            border-radius: 50%;
            animation: spin 1s linear infinite;
        }
        @keyframes spin {
            0% { transform: rotate(0deg); }
            100% { transform: rotate(360deg); }
        }
        .btn-coincidence {
            margin: 2px;
            padding: 5px 10px;
            font-size: 0.8rem;
        }
        .planet-list-item {
            padding: 8px;
            margin: 5px 0;
            border-radius: 4px;
            cursor: pointer;
        }
        .planet-list-item:hover {
            background-color: #f0f0f0;
        }
        .planet-list-item.selected {
            background-color: #e3f2fd;
        }
        .aspect-list-item {
            padding: 8px;
            margin: 5px 0;
            border-radius: 4px;
            cursor: pointer;
        }
        .aspect-list-item:hover {
            background-color: #f0f0f0;
        }
        .aspect-list-item.selected {
            background-color: #e3f2fd;
        }
        .dignity-domicilio {
            color: #00AA00;
            font-weight: bold;
        }
        .dignity-exaltacion {
            color: #4444FF;
            font-weight: bold;
        }
        .dignity-peregrino {
            color: #888888;
        }
        .dignity-caida {
            color: #AA5500;
            font-weight: bold;
        }
        .dignity-exilio {
            color: #AA0000;
            font-weight: bold;
        }
        .enlace-item {
            padding: 8px;
            margin: 5px 0;
            border-radius: 4px;
            border-left: 4px solid #ddd;
        }
        .enlace-fuerte {
            border-left-color: #28a745;
            background-color: #f0fff0;
        }
        .enlace-medio {
            border-left-color: #ffc107;
            background-color: #fffff0;
        }
        .enlace-debil {
            border-left-color: #dc3545;
            background-color: #fff0f0;
        }
        .pico-item {
            padding: 10px;
            margin: 5px 0;
            border-radius: 4px;
            background-color: #f8f9fa;
            border-left: 4px solid #28a745;
        }
        .header-title {
            text-align: center;
            margin-bottom: 30px;
            color: #1a237e;
            font-size: 2.5rem;
            font-weight: bold;
            text-shadow: 1px 1px 2px rgba(0,0,0,0.1);
            padding: 10px 0;
            border-bottom: 2px solid #3949ab;
            background-color: #f5f5f5;
            border-radius: 10px;
        }
        /* Nuevos estilos para predicciones */
        .predicciones-container {
            background-color: white;
            border-radius: 10px;
            box-shadow: 0 4px 8px rgba(0, 0, 0, 0.1);
            padding: 20px;
            margin-bottom: 20px;
            max-height: 600px;
            overflow-y: auto;
        }
        .prediccion-item {
            padding: 8px;
            margin: 5px 0;
            border-radius: 4px;
            cursor: pointer;
            border-left: 4px solid #007bff;
            background-color: #f8f9fa;
        }
        .prediccion-item:hover {
            background-color: #e9ecef;
        }
        .prediccion-fecha {
            font-weight: bold;
        }
        .prediccion-pico-mayor {
            border-left-color: #dc3545;
        }
        .prediccion-pico-moderado {
            border-left-color: #fd7e14;
        }
        .prediccion-pico-menor {
            border-left-color: #ffc107;
        }
        .prediccion-liberacion {
            border-left-color: #28a745;
        }
        .prediccion-disolucion {
            border-left-color: #6c757d;
        }
        .date-filter {
            margin-bottom: 15px;
        }
        .year-group {
            margin-bottom: 15px;
            border: 1px solid #dee2e6;
            border-radius: 5px;
        }
        .year-header {
            padding: 10px 15px;
            background-color: #f8f9fa;
            border-bottom: 1px solid #dee2e6;
            font-weight: bold;
            cursor: pointer;
        }
        /* Estilos para botones de puntos de referencia */
        .punto-referencia-btn {
            margin-right: 5px;
            margin-bottom: 10px;
        }
        .punto-referencia-btn.active {
            background-color: #0d6efd;
            color: white;
        }
        .punto-info {
            margin-top: 10px;
            padding: 10px;
            background-color: #f8f9fa;
            border-radius: 5px;
            border-left: 4px solid #0d6efd;
        }
        /* Estilos para Relevo Zodiacal */
        .relevo-periodo {
            padding: 10px;
            margin-bottom: 10px;
            border-radius: 4px;
            border-left: 4px solid #ccc;
        }

        .relevo-subperiodo {
            margin-left: 20px;
            margin-bottom: 5px;
            padding: 8px;
            border-radius: 4px;
            border-left: 3px solid #ddd;
        }

        .relevo-subsubperiodo {
            margin-left: 40px;
            margin-bottom: 5px;
            padding: 6px;
            border-radius: 4px;
            border-left: 2px solid #eee;
        }

        /* Nuevo estilo para el cuarto nivel */
            .relevo-subsubsubperiodo {
                margin-left: 60px;
                margin-bottom: 5px;
                padding: 4px;
                border-radius: 4px;
                border-left: 1px solid #f5f5f5;
            }

        /* Estilos mejorados para elementos */
        .fuego {
            background-color: #ffeded;
            border-left-color: #ff5757;
        }

        .tierra {
            background-color: #f0f7e6;
            border-left-color: #7fb352;
        }

        .aire {
            background-color: #fffde6;
            border-left-color: #ffd633;
        }

        .agua {
            background-color: #e6e6ff;
            border-left-color: #8080ff;
        }
    </style>
</head>
<body>
    <div class="container">
        <h1 class="header-title">Relevo Zodiacal</h1>
        
        <div class="loading" id="loadingIndicator">
            <div class="loading-spinner"></div>
        </div>
        
        <!-- Formulario de entrada -->
        <div class="controls-container mb-4">
            <div class="row">
                <div class="col-md-4">
                    <div class="mb-3">
                        <label for="city" class="form-label">Ciudad de Nacimiento</label>
                        <input type="text" class="form-control" id="city" placeholder="Ej: Madrid, España" list="cityList">
                        <datalist id="cityList"></datalist>
                    </div>
                </div>
                <div class="col-md-4">
                    <div class="mb-3">
                        <label for="date" class="form-label">Fecha de Nacimiento</label>
                        <input type="date" class="form-control" id="date">
                    </div>
                </div>
                <div class="col-md-4">
                    <div class="mb-3">
                        <label for="time" class="form-label">Hora de Nacimiento</label>
                        <input type="time" class="form-control" id="time">
                    </div>
                </div>
                <div class="row mt-3">
                    <div class="col-md-12">
                        <div class="d-grid gap-2">
                            <button class="btn btn-primary" id="calculateBtn">Calcular Carta Astral</button>
                            <button class="btn btn-info" id="calculatePredictionsBtn" onclick="calculatePredictions()">Calcular Predicciones</button>
                            <button class="btn btn-outline-secondary" id="demoPredictionsBtn" onclick="generarPrediccionesDemo()">Mostrar Ejemplo Demo</button>
                        </div>
                    </div>
                </div>
            </div>
            
            <!-- Formulario de tránsitos -->
            <div class="row mb-3">
                <div class="col-md-4">
                    <div class="form-check form-switch">
                        <input class="form-check-input" type="checkbox" id="showTransits" checked>
                        <label class="form-check-label" for="showTransits">Mostrar Tránsitos</label>
                    </div>
                </div>
                <div class="col-md-4">
                    <div class="form-check form-switch">
                        <input class="form-check-input" type="checkbox" id="calculateAnalysis" checked>
                        <label class="form-check-label" for="calculateAnalysis">Análisis Avanzado</label>
                    </div>
                </div>
            </div>

            <div id="transitsContainer">
                <div class="row">
                    <div class="col-md-4">
                        <div class="mb-3">
                            <label for="transitCity" class="form-label">Ciudad de Tránsito</label>
                            <input type="text" class="form-control" id="transitCity" placeholder="Ej: Madrid, España" list="transitCityList">
                            <datalist id="transitCityList"></datalist>
                        </div>
                    </div>
                    <div class="col-md-4">
                        <div class="mb-3">
                            <label for="transitDate" class="form-label">Fecha de Tránsito</label>
                            <input type="date" class="form-control" id="transitDate">
                        </div>
                    </div>
                    <div class="col-md-4">
                        <div class="mb-3">
                            <label for="transitTime" class="form-label">Hora de Tránsito</label>
                            <input type="time" class="form-control" id="transitTime">
                        </div>
                    </div>
                </div>
            </div>

            <div class="d-grid gap-2">
                <button class="btn btn-primary" id="calculateBtn">Calcular Carta Astral</button>
            </div>

            <div class="alert alert-danger mt-3 d-none" id="errorAlert" role="alert"></div>
            <div class="alert alert-info mt-3 d-none" id="infoBox">
                <span id="ascendenteInfo"></span><br>
                <span id="birthTypeInfo"></span>
            </div>
        </div>
        
        <div class="row" id="chartContent" style="display: none;">
            <!-- Rueda Zodiacal -->
            <div class="col-md-8">
                <div class="chart-container">
                    <div class="wheel-container">
                        <svg id="chartSvg" class="chart-svg" viewBox="0 0 600 600"></svg>
                        <div id="chartTooltip" class="tooltip-custom" style="display: none;"></div>
                    </div>
                </div>
                
                <div class="predicciones-container d-none" id="prediccionesContainer">                    
                    <div class="date-filter mb-3">
                        <div class="row">
                            <div class="col-md-6">
                                <label for="yearFilter" class="form-label">Filtrar por Año:</label>
                                <select class="form-select" id="yearFilter">
                                    <option value="all">Todos los años</option>
                                </select>
                            </div>
                            <div class="col-md-6">
                                <label for="tipoPrediccion" class="form-label">Tipo de Predicción:</label>
                                <select class="form-select" id="tipoPrediccion">
                                    <option value="all">Todas las predicciones</option>
                                    <option value="pico-mayor">Picos mayores</option>
                                    <option value="pico-moderado">Picos moderados</option>
                                    <option value="pico-menor">Picos menores</option>
                                    <option value="liberacion">Liberaciones</option>
                                    <option value="disolucion">Disoluciones</option>
                                </select>
                            </div>
                        </div>
                    </div>
    
                    <div id="prediccionesList">
                        <div class="alert alert-info">
                            <p>Para ver predicciones, utilice el botón "Calcular Predicciones" después de generar la carta natal.</p>
                            <p>O pruebe "Mostrar Ejemplo Demo" para ver un ejemplo con datos simulados.</p>
                        </div>
                    </div>
                </div>
            
            <!-- Información y Coincidencias -->
            <div class="col-md-4">
                <ul class="nav nav-tabs" id="myTab" role="tablist">
                    <li class="nav-item" role="presentation">
                        <button class="nav-link active" id="planets-tab" data-bs-toggle="tab" data-bs-target="#planets" type="button" role="tab" aria-controls="planets" aria-selected="true">Planetas</button>
                    </li>
                    <li class="nav-item" role="presentation">
                        <button class="nav-link" id="aspects-tab" data-bs-toggle="tab" data-bs-target="#aspects" type="button" role="tab" aria-controls="aspects" aria-selected="false">Aspectos</button>
                    </li>
                    <li class="nav-item" role="presentation">
                        <button class="nav-link" id="advanced-tab" data-bs-toggle="tab" data-bs-target="#advanced" type="button" role="tab" aria-controls="advanced" aria-selected="false">Avanzado</button>
                    </li>
                </ul>
                <div class="tab-content" id="myTabContent">
                    <!-- Pestaña de Planetas -->
                    <div class="tab-pane fade show active" id="planets" role="tabpanel" aria-labelledby="planets-tab">
                        <h4>Carta Natal</h4>
                        <div id="natalPlanets"></div>
                        
                        <h4 class="mt-4">Tránsitos</h4>
                        <div id="transitPlanets"></div>
                    </div>
                    
                    <!-- Pestaña de Aspectos -->
                    <div class="tab-pane fade" id="aspects" role="tabpanel" aria-labelledby="aspects-tab">
                        <h4>Aspectos Internos</h4>
                        <div id="internalAspects"></div>

                        <h4 class="mt-4">Aspectos entre Cartas</h4>
                        <div id="interChartAspects"></div>
                    </div>
                    
                    <!-- Pestaña de Avanzado -->
                    <div class="tab-pane fade" id="advanced" role="tabpanel" aria-labelledby="advanced-tab">
                        <h4>Enlaces Planetarios y Disolución</h4>
                        <p>Conexiones y disoluciones de enlaces entre planetas:</p>
                        <div id="enlacesPlanetarios"></div>
                        
                        <h4 class="mt-4">Picos</h4>
                        <p>Los picos representan momentos de alta influencia planetaria:</p>
                        
                        <h5 class="mt-3">Pico Mayor</h5>
                        <div id="picoMayor"></div>
                        
                        <h5 class="mt-3">Pico Moderado</h5>
                        <div id="picoModerado"></div>
                        
                        <h5 class="mt-3">Pico Menor</h5>
                        <div id="picoMenor"></div>
                        
                        <h4 class="mt-4">Liberación de Enlace</h4>
                        <div id="liberacionEnlace"></div>
                        
                        <h4 class="mt-4">Presagios</h4>
                        <div id="presagios"></div>
                        
                        <!-- Sección Relevo Zodiacal Modificada -->
                        <div id="relevoZodiacalSection">
                            <h4 class="mt-4">Relevo Zodiacal</h4>
                            <p>Periodos y subperiodos activos en la fecha de tránsito:</p>
                            <!-- Add this inside the div with id="relevoZodiacalSection", just before the relevoZodiacalContainer div -->
<div class="mb-3">
    <h5>Punto de referencia para el Relevo Zodiacal:</h5>
    <div class="form-check form-check-inline">
        <input class="form-check-input" type="radio" name="puntoReferenciaRelevo" id="referenciaASC" value="ASC" checked>
        <label class="form-check-label" for="referenciaASC">Ascendente</label>
    </div>
    <div class="form-check form-check-inline">
        <input class="form-check-input" type="radio" name="puntoReferenciaRelevo" id="referenciaPF" value="PARTE_FORTUNA">
        <label class="form-check-label" for="referenciaPF">Parte de Fortuna</label>
    </div>
    <div class="form-check form-check-inline">
        <input class="form-check-input" type="radio" name="puntoReferenciaRelevo" id="referenciaPE" value="PARTE_ESPIRITU">
        <label class="form-check-label" for="referenciaPE">Parte del Espíritu</label>
    </div>
</div>
                            <div id="relevoZodiacalContainer">
                                <div class="alert alert-info">
                                    Calculando relevo zodiacal...
                                </div>
                            </div>
                        </div>
                    </div>
                </div>
            </div>
        </div>
    </div>

    <!-- Bootstrap y Librerías JS -->
    <script src="https://cdn.jsdelivr.net/npm/bootstrap@5.2.3/dist/js/bootstrap.bundle.min.js"></script>

    <!-- Script principal -->
    <script>
    document.addEventListener('DOMContentLoaded', function() {
        console.log("Script de astrología iniciado");
        
        // Constantes globales
        const DIMENSIONS = {
            centerX: 300,
            centerY: 300,
            radius: 280,
            middleRadius: 190, // Radio para la carta externa (tránsitos)
            innerRadius: 110,  // Radio para la carta interna (natal)
            glyphRadius: 265
        };

        const SIGNS = [
            {name: 'ARIES', start: 354, length: 36, symbol: '♈', color: '#FFE5E5'},
            {name: 'TAURUS', start: 30, length: 30, symbol: '♉', color: '#E5FFE5'},
            {name: 'GEMINI', start: 60, length: 30, symbol: '♊', color: '#FFFFE5'},
            {name: 'CANCER', start: 90, length: 30, symbol: '♋', color: '#E5FFFF'},
            {name: 'LEO', start: 120, length: 30, symbol: '♌', color: '#FFE5E5'},
            {name: 'VIRGO', start: 150, length: 36, symbol: '♍', color: '#E5FFE5'},
            {name: 'LIBRA', start: 186, length: 24, symbol: '♎', color: '#FFFFE5'},
            {name: 'SCORPIO', start: 210, length: 30, symbol: '♏', color: '#E5FFFF'},
            {name: 'OPHIUCHUS', start: 240, length: 12, symbol: '⛎', color: '#FFFFE5'},
            {name: 'SAGITTARIUS', start: 252, length: 18, symbol: '♐', color: '#FFE5E5'},
            {name: 'CAPRICORN', start: 270, length: 36, symbol: '♑', color: '#E5FFE5'},
            {name: 'AQUARIUS', start: 306, length: 18, symbol: '♒', color: '#FFFFE5'},
            {name: 'PEGASUS', start: 324, length: 6, symbol: '∩', color: '#E5FFFF'},
            {name: 'PISCES', start: 330, length: 24, symbol: '♓', color: '#E5FFFF'}
        ];

        const PLANET_SYMBOLS = {
            'SOL': '☉',
            'LUNA': '☽',
            'MERCURIO': '☿',
            'VENUS': '♀',
            'MARTE': '♂',
            'JÚPITER': '♃',
            'SATURNO': '♄',
            'URANO': '♅',
            'NEPTUNO': '♆',
            'PLUTÓN': '♇',
            'ASC': 'ASC',
            'MC': 'MC',
            'DSC': 'DSC',
            'IC': 'IC',
            'PARTE_FORTUNA': 'PF',
            'PARTE_ESPIRITU': 'PE'
        };

        const ASPECTS = {
            'CONJUNCTION': { angle: 0, orb: 2, color: '#000080', name: 'Armónico Relevante' },
            'SEXTILE': { angle: 60, orb: 2, color: '#000080', name: 'Armónico Relevante' },
            'SQUARE': { angle: 90, orb: 2, color: '#FF0000', name: 'Inarmónico Relevante' },
            'TRINE': { angle: 120, orb: 2, color: '#000080', name: 'Armónico Relevante' },
            'OPPOSITION': { angle: 180, orb: 2, color: '#000080', name: 'Armónico Relevante' }
        };

        const COLORS = {
            RED: '#FF0000',
            GREEN: '#00FF00',
            BLUE: '#0000FF',
            YELLOW: '#FFFF00'
        };
        
        const DIGNIDAD_LABELS = {
            'domicilio': 'Domicilio',
            'exaltacion': 'Exaltación',
            'peregrino': 'Peregrino',
            'caida': 'Caída',
            'exilio': 'Exilio'
        };

        // Constantes para Relevo Zodiacal
        const DURACIONES = {
            AÑO: 364,
            MES: 28,
            SEMANA: 7,
            DIA: 1
        };
        
        const DURACION_POR_NIVEL = {
            'virgo': 4, 'libra': 3, 'escorpio': 5, 'ofiuco': 7, 'sagitario': 2,
            'capricornio': 1, 'acuario': 6, 'piscis': 2, 'aries': 5, 'tauro': 3,
            'geminis': 4, 'cancer': 6, 'leo': 1
        };
        
        const SIGNOS = {
            'virgo': {'planeta': 'MERCURIO', 'años': 4},
            'libra': {'planeta': 'VENUS', 'años': 3},
            'escorpio': {'planeta': 'MARTE', 'años': 5},
            'ofiuco': {'planeta': 'SATURNO', 'años': 7},
            'sagitario': {'planeta': 'JÚPITER', 'años': 2},
            'capricornio': {'planeta': 'SOL', 'años': 1},
            'acuario': {'planeta': 'LUNA', 'años': 6},
            'piscis': {'planeta': 'JÚPITER', 'años': 2},
            'aries': {'planeta': 'MARTE', 'años': 5},
            'tauro': {'planeta': 'VENUS', 'años': 3},
            'geminis': {'planeta': 'MERCURIO', 'años': 4},
            'cancer': {'planeta': 'LUNA', 'años': 6},
            'leo': {'planeta': 'SOL', 'años': 1}
        };
        
        // Mapa de elementos para los signos
        const ELEMENTOS_SIGNOS = {
            'ARIES': {elemento: 'Fuego', color: '#ffeded', borde: '#ff5757'},
            'LEO': {elemento: 'Fuego', color: '#fff0e8', borde: '#ff7b47'},
            'SAGITTARIUS': {elemento: 'Fuego', color: '#fff5e6', borde: '#ff9933'},
            'TAURUS': {elemento: 'Tierra', color: '#f0f7e6', borde: '#7fb352'},
            'VIRGO': {elemento: 'Tierra', color: '#e8f2dc', borde: '#6b9944'},
            'CAPRICORN': {elemento: 'Tierra', color: '#f0e6d2', borde: '#b38c52'},
            'GEMINI': {elemento: 'Aire', color: '#e8f0fa', borde: '#47a0ff'},
            'LIBRA': {elemento: 'Aire', color: '#e6f2ff', borde: '#33a3ff'},
            'AQUARIUS': {elemento: 'Aire', color: '#e6f9ff', borde: '#33ccff'},
            'OPHIUCHUS': {elemento: 'Aire', color: '#e6f5ff', borde: '#4d94ff'},
            'CANCER': {elemento: 'Agua', color: '#e6e6ff', borde: '#8080ff'},
            'SCORPIO': {elemento: 'Agua', color: '#ede6ff', borde: '#9966ff'},
            'PISCES': {elemento: 'Agua', color: '#e6f2ff', borde: '#66b3ff'}
        };
        
        // Normalización de nombres de signos
        const SIGNOS_NORMALIZADOS = {
            'aries': 'ARIES',
            'tauro': 'TAURUS',
            'geminis': 'GEMINI',
            'géminis': 'GEMINI',
            'cancer': 'CANCER',
            'cáncer': 'CANCER',
            'leo': 'LEO',
            'virgo': 'VIRGO',
            'libra': 'LIBRA',
            'escorpio': 'SCORPIO',
            'ofiuco': 'OPHIUCHUS',
            'sagitario': 'SAGITTARIUS',
            'capricornio': 'CAPRICORN',
            'acuario': 'AQUARIUS',
            'piscis': 'PISCES'
        };

        // Variables globales
        let natalPlanets = [];
        let transitPlanets = [];
        let internalAspects = [];
        let interChartAspects = [];
        let enlaces = [];
        let selectedPlanet = null;
        let selectedAspect = null;
        let isDry = null;
        let ascendenteName = '';
        let birthDate = null;
        
        // Variables para funcionalidad extendida
        window.pico_mayor = [];
        window.pico_moderado = [];
        window.pico_menor = [];
        window.liberacion_enlace = [];
        window.presagios = {buenos: [], malos: []};
        
        // Variables para predicciones
        let predicciones = {
            picosMayor: [],
            picosModerado: [],
            picosMenor: [],
            liberaciones: [],
            disoluciones: []
        };
        
        // Variable para puntos de referencia
        let puntosReferencia = {};
        let puntoReferenciaSeleccionado = null;

        // Elementos DOM
        const cityInput = document.getElementById('city');
        const cityList = document.getElementById('cityList');
        const dateInput = document.getElementById('date');
        const timeInput = document.getElementById('time');
        const transitCityInput = document.getElementById('transitCity');
        const transitCityList = document.getElementById('transitCityList');
        const transitDateInput = document.getElementById('transitDate');
        const transitTimeInput = document.getElementById('transitTime');
        const showTransitsToggle = document.getElementById('showTransits');
        const calculateAnalysisToggle = document.getElementById('calculateAnalysis');
        const calculatePredictionsToggle = document.getElementById('calculatePredictions');
        const transitsContainer = document.getElementById('transitsContainer');
        const calculateBtn = document.getElementById('calculateBtn');
        const chartContent = document.getElementById('chartContent');
        const chartSvg = document.getElementById('chartSvg');
        const natalPlanetsContainer = document.getElementById('natalPlanets');
        const transitPlanetsContainer = document.getElementById('transitPlanets');
        const internalAspectsContainer = document.getElementById('internalAspects');
        const interChartAspectsContainer = document.getElementById('interChartAspects');
        // Elementos DOM para análisis avanzado
        const enlacesPlanetariosContainer = document.getElementById('enlacesPlanetarios');
        const picoMayorContainer = document.getElementById('picoMayor');
        const picoModeradoContainer = document.getElementById('picoModerado');
        const picoMenorContainer = document.getElementById('picoMenor');
        const liberacionEnlaceContainer = document.getElementById('liberacionEnlace');
        const presagiosContainer = document.getElementById('presagios');
        const loadingIndicator = document.getElementById('loadingIndicator');
        const chartTooltip = document.getElementById('chartTooltip');
        const errorAlert = document.getElementById('errorAlert');
        const infoBox = document.getElementById('infoBox');
        const ascendenteInfo = document.getElementById('ascendenteInfo');
        const birthTypeInfo = document.getElementById('birthTypeInfo');
        // Elementos DOM para predicciones
        const prediccionesContainer = document.getElementById('prediccionesContainer');
        const prediccionesList = document.getElementById('prediccionesList');
        const yearFilterSelect = document.getElementById('yearFilter');
        const tipoPrediccionSelect = document.getElementById('tipoPrediccion');
        // Elementos DOM para puntos de referencia
        const puntosReferenciaContainer = document.getElementById('puntosReferenciaContainer');
        const puntosReferenciaBtns = document.getElementById('puntosReferenciaBtns');
        const puntoInfo = document.getElementById('puntoInfo');
        // Elementos DOM para Relevo Zodiacal
        const relevoZodiacalContainer = document.getElementById('relevoZodiacalContainer');
        const btnMostrarRelevo = document.getElementById('btnMostrarRelevo');

        // Función debounce para limitar llamadas a funciones
        function debounce(func, wait) {
            let timeout;
            return function() {
                const context = this;
                const args = arguments;
                clearTimeout(timeout);
                timeout = setTimeout(() => {
                    func.apply(context, args);
                }, wait);
            };
        }

        // Función para mostrar mensajes de error
        function showError(message) {
            console.error("Error:", message);
            errorAlert.textContent = message;
            errorAlert.classList.remove('d-none');
        }

        // Función para ocultar mensajes de error
        function hideError() {
            errorAlert.textContent = '';
            errorAlert.classList.add('d-none');
        }

        // Función para mostrar tooltip
        function showTooltip(event, text) {
            chartTooltip.textContent = text;
            chartTooltip.style.display = 'block';
            
            // Posicionar el tooltip cerca del cursor
            const rect = chartSvg.getBoundingClientRect();
            const x = event.clientX - rect.left;
            const y = event.clientY - rect.top;
            
            chartTooltip.style.left = `${x + 15}px`;
            chartTooltip.style.top = `${y + 15}px`;
        }

        // Función para ocultar tooltip
        function hideTooltip() {
            chartTooltip.style.display = 'none';
        }

        // Función para mostrar información del tipo de nacimiento
        function showBirthInfo(ascendente, esSeco) {
            ascendenteInfo.textContent = `Ascendente: ${ascendente}`;
            birthTypeInfo.textContent = `Tu nacimiento es de tipo ${esSeco ? 'seco' : 'húmedo'}`;
            infoBox.classList.remove('d-none');
        }

        // Función para manejar la búsqueda de ciudades - ACTUALIZADA para usar directamente Geoapify
        function handleCitySearch(searchText, isTransit) {
            const searchQuery = searchText.trim();
            const resultsContainer = isTransit ? transitCityList : cityList;
            
            if (searchQuery.length < 3) {
                resultsContainer.innerHTML = '';
                return;
            }
            
            console.log(`Buscando ciudad: ${searchQuery} (${isTransit ? 'tránsito' : 'natal'})`);
            
            // Usar directamente Geoapify en lugar del endpoint /cities
            // API Key tomada directamente del código server.py
            const API_KEY = "e19afa2a9d6643ea9550aab89eefce0b";
            const url = `https://api.geoapify.com/v1/geocode/search?text=${encodeURIComponent(searchQuery)}&apiKey=${API_KEY}`;
            
            fetch(url)
                .then(response => {
                    console.log("Respuesta de Geoapify recibida:", response.status);
                    if (!response.ok) {
                        throw new Error(`Error en la respuesta: ${response.status}`);
                    }
                    return response.json();
                })
                .then(data => {
                    console.log("Datos de ciudades:", data);
                    // Limpiar datalist
                    resultsContainer.innerHTML = '';
                    
                    // Añadir opciones
                    if (data.features && data.features.length > 0) {
                        // Convertir los resultados de Geoapify al formato esperado por la aplicación
                        const ciudades = data.features.map(feature => ({
                            nombre: feature.properties.formatted,
                            lat: feature.properties.lat,
                            lon: feature.properties.lon,
                            pais: feature.properties.country || ""
                        }));
                        
                        ciudades.forEach(ciudad => {
                            const option = document.createElement('option');
                            option.value = ciudad.nombre;
                            option.setAttribute('data-lat', ciudad.lat);
                            option.setAttribute('data-lon', ciudad.lon);
                            resultsContainer.appendChild(option);
                        });
                    } else {
                        // Ciudades de ejemplo si no hay resultados
                        const examples = [
                            { nombre: `${searchQuery}, España`, lat: 40.416, lon: -3.703 },
                            { nombre: `${searchQuery}, México`, lat: 19.432, lon: -99.133 },
                            { nombre: `${searchQuery}, Argentina`, lat: -34.603, lon: -58.381 }
                        ];
                        
                        examples.forEach(ciudad => {
                            const option = document.createElement('option');
                            option.value = ciudad.nombre;
                            option.setAttribute('data-lat', ciudad.lat);
                            option.setAttribute('data-lon', ciudad.lon);
                            resultsContainer.appendChild(option);
                        });
                    }
                })
                .catch(error => {
                    console.error('Error buscando ciudades:', error);
                    showError(`Error buscando ciudades: ${error.message}`);
                    
                    // Proporcionar algunas ciudades de ejemplo en caso de error
                    resultsContainer.innerHTML = '';
                    const examples = [
                        { nombre: "Bilbao, España", lat: 43.263, lon: -2.935 },
                        { nombre: "Madrid, España", lat: 40.416, lon: -3.703 },
                        { nombre: "Barcelona, España", lat: 41.385, lon: 2.173 },
                        { nombre: "Valencia, España", lat: 39.469, lon: -0.376 },
                        { nombre: "Sevilla, España", lat: 37.389, lon: -5.984 }                        
                    ];
                    
                    examples.forEach(ciudad => {
                        const option = document.createElement('option');
                        option.value = ciudad.nombre;
                        option.setAttribute('data-lat', ciudad.lat);
                        option.setAttribute('data-lon', ciudad.lon);
                        resultsContainer.appendChild(option);
                    });
                });
        }

        // Función para mostrar/ocultar sección de tránsitos
        function toggleTransits() {
            const isChecked = showTransitsToggle.checked;
            
            if (isChecked) {
                transitsContainer.style.opacity = '1';
                transitsContainer.style.pointerEvents = 'auto';
            } else {
                transitsContainer.style.opacity = '0.5';
                transitsContainer.style.pointerEvents = 'none';
            }
        }

        // Función para obtener la opción seleccionada de una ciudad
        function getSelectedCityCoordinates(inputElement, datalistElement) {
            const cityValue = inputElement.value;
            
            // Buscar la opción en el datalist que coincida con el valor introducido
            for (let i = 0; i < datalistElement.options.length; i++) {
                const option = datalistElement.options[i];
                if (option.value === cityValue) {
                    return {
                        lat: parseFloat(option.getAttribute('data-lat')),
                        lon: parseFloat(option.getAttribute('data-lon'))
                    };
                }
            }
            
            // Coordenadas por defecto si no se encuentra (Madrid)
            return { lat: 40.416, lon: -3.703 };
        }

        // Modified calculateChart function to remove predictions calculation
function calculateChart() {
    // Validate inputs
    if (!cityInput.value || !dateInput.value || !timeInput.value) {
        showError("Debes ingresar ciudad, fecha y hora para la carta natal.");
        return;
    }
    
    if (showTransitsToggle.checked && (!transitCityInput.value || !transitDateInput.value || !transitTimeInput.value)) {
        showError("Debes ingresar ciudad, fecha y hora para los tránsitos.");
        return;
    }
    
    // Show loading
    loadingIndicator.style.display = 'flex';
    hideError();
    
    // Get coordinates of the selected city
    const natalCoords = getSelectedCityCoordinates(cityInput, cityList);
    
    console.log("Calculando carta astral...");
    console.log("Datos natal:", {
        city: cityInput.value,
        date: dateInput.value,
        time: timeInput.value,
        lat: natalCoords.lat,
        lon: natalCoords.lon
    });
    
    // Save birth date for later use
    birthDate = dateInput.value;
    window.birthDate = birthDate;
    
    // Calculate natal chart - Include coordinates in the request
    const natalData = {
        city: cityInput.value,
        date: dateInput.value,
        time: timeInput.value,
        lat: natalCoords.lat,
        lon: natalCoords.lon,
        calculateAnalysis: calculateAnalysisToggle.checked
    };
    
    fetch('/calculate', {
        method: 'POST',
        headers: {
            'Content-Type': 'application/json'
        },
        body: JSON.stringify(natalData)
    })
    .then(response => {
        console.log("Respuesta recibida:", response.status);
        return response.json();
    })
    .then(data => {
        console.log("Datos de la carta natal:", data);
        
        if (data.error) {
            throw new Error(data.error);
        }
        
        // Save basic data
        natalPlanets = data.positions;
        window.natalPlanets = natalPlanets;
        internalAspects = data.aspects;
        
        // Save advanced analysis results if available
        if (data.enlaces) enlaces = data.enlaces;
        if (data.pico_mayor) window.pico_mayor = data.pico_mayor;
        if (data.pico_moderado) window.pico_moderado = data.pico_moderado;
        if (data.pico_menor) window.pico_menor = data.pico_menor;
        if (data.liberacion_enlace) window.liberacion_enlace = data.liberacion_enlace;
        if (data.presagios) window.presagios = data.presagios;
        
        isDry = data.isDry;
        window.isDry = isDry;
        
        // Show ascendant information
        const ascPlanet = natalPlanets.find(p => p.name === 'ASC');
        if (ascPlanet) {
            ascendenteName = ascPlanet.sign;
            window.ascendenteName = ascendenteName;
            showBirthInfo(ascPlanet.sign, isDry);
        }
        
        // If there are transits, calculate them as well
        if (showTransitsToggle.checked) {
            console.log("Calculando tránsitos...");
            
            // Get coordinates of the transit city
            const transitCoords = getSelectedCityCoordinates(transitCityInput, transitCityList);
            
            console.log("Datos tránsito:", {
                city: transitCityInput.value,
                date: transitDateInput.value,
                time: transitTimeInput.value,
                lat: transitCoords.lat,
                lon: transitCoords.lon
            });
            
            fetch('/calculate', {
                method: 'POST',
                headers: {
                    'Content-Type': 'application/json'
                },
                body: JSON.stringify({
                    city: transitCityInput.value,
                    date: transitDateInput.value,
                    time: transitTimeInput.value,
                    lat: transitCoords.lat,
                    lon: transitCoords.lon,
                    calculateAnalysis: calculateAnalysisToggle.checked
                })
            })
            .then(transitResponse => {
                console.log("Respuesta de tránsitos recibida:", transitResponse.status);
                return transitResponse.json();
            })
            .then(transitData => {
                console.log("Datos de tránsitos:", transitData);
                
                if (transitData.error) {
                    throw new Error(transitData.error);
                }
                
                transitPlanets = transitData.positions;
                
                // Calculate aspects between charts
                interChartAspects = calculateAspects(natalPlanets, transitPlanets);
                
                // Render full chart
                renderChart();

                // Calculate zodiacal relay (new automatic function)
                calcularYMostrarRelevoZodiacal();
            })
            .catch(error => {
                console.error('Error calculando tránsitos:', error);
                showError("Error calculando tránsitos: " + error.message);
                loadingIndicator.style.display = 'none';
            });
        } else {
            transitPlanets = [];
            interChartAspects = [];
            renderChart();
            
            // Calculate zodiacal relay (new automatic function)
            calcularYMostrarRelevoZodiacal();
        }
    })
    .catch(error => {
        console.error('Error calculando carta:', error);
        showError("Error calculando carta: " + error.message);
        loadingIndicator.style.display = 'none';
    });
}

        // Función para calcular predicciones a largo plazo - MEJORADA
function calculatePredictions() {
    console.log("Calculando predicciones a largo plazo...");
    
    // Mostrar contenedor de predicciones
    prediccionesContainer.classList.remove('d-none');
    prediccionesList.innerHTML = '<div class="alert alert-info">Calculando predicciones... Esto puede tardar unos momentos.</div>';
    
    // Verificar que tenemos los datos necesarios
    if (!birthDate) {
        prediccionesList.innerHTML = '<div class="alert alert-warning">No se pudo determinar la fecha de nacimiento. Por favor, complete la carta natal primero.</div>';
        return;
    }
    
    if (!isDry && isDry !== false) {
        prediccionesList.innerHTML = '<div class="alert alert-warning">No se pudo determinar si la carta es seca o húmeda. Por favor, complete la carta natal primero.</div>';
        return;
    }
    
    if (!ascendenteName) {
        prediccionesList.innerHTML = '<div class="alert alert-warning">No se pudo determinar el ascendente. Por favor, complete la carta natal primero.</div>';
        return;
    }
    
    // Obtener datos de la fecha de nacimiento
    const birthDateObj = new Date(birthDate);
    const birthYear = birthDateObj.getFullYear();
    
    // Definir rango de años para predicciones (por defecto, 84 años desde el nacimiento)
    const startYear = birthYear;
    const endYear = birthYear + 84;
    
    console.log(`Calculando predicciones desde ${startYear} hasta ${endYear}`);
    
    // Preparar datos para enviar
    const predictionsData = {
        birthDate: birthDate,
        isDry: isDry,
        ascendente: ascendenteName,
        startYear: startYear,
        endYear: endYear,
        puntoReferencia: puntoReferenciaSeleccionado,
        cartaNatal: natalPlanets
    };
    
    // Mostrar información del cálculo
    prediccionesList.innerHTML = `
        <div class="alert alert-info">
            <p>Calculando predicciones para:</p>
            <ul>
                <li>Fecha de nacimiento: ${new Date(birthDate).toLocaleDateString('es-ES')}</li>
                <li>Tipo de carta: ${isDry ? 'Seca (diurna)' : 'Húmeda (nocturna)'}</li>
                <li>Ascendente: ${ascendenteName}</li>
                <li>Punto de referencia: ${puntoReferenciaSeleccionado || 'Todos'}</li>
                <li>Período: ${startYear} - ${endYear}</li>
            </ul>
        </div>
    `;
    
    // Si estamos en modo demo/cliente (sin servidor), generar predicciones simuladas
    if (typeof window.demoMode !== 'undefined' && window.demoMode) {
        console.log("Modo demo activado, generando predicciones simuladas");
        
        // Simulamos una pequeña demora para que parezca que está calculando
        setTimeout(() => {
            predicciones = generarPrediccionesSimuladas(birthDateObj, startYear, endYear);
            
            // Generar lista de años para el filtro
            generateYearOptions();
            
            // Mostrar predicciones
            renderPredictions();
        }, 1500);
        
        return;
    }
    
    // Llamada al servidor para calcular predicciones
    fetch('/calculate_forecasts', {
        method: 'POST',
        headers: {
            'Content-Type': 'application/json'
        },
        body: JSON.stringify(predictionsData)
    })
    .then(response => {
        console.log("Respuesta de predicciones recibida:", response.status);
        return response.json();
    })
    .then(data => {
        console.log("Predicciones recibidas:", data);
        
        if (data.error) {
            throw new Error(data.error);
        }
        
        // Guardar predicciones
        predicciones.picosMayor = data.picos?.mayor || [];
        predicciones.picosModerado = data.picos?.moderado || [];
        predicciones.picosMenor = data.picos?.menor || [];
        predicciones.liberaciones = data.liberaciones || [];
        predicciones.disoluciones = data.disoluciones || [];
        
        // Guardar información de puntos de referencia
        if (data.puntos_referencia) {
            puntosReferencia = data.puntos_referencia;
            // Generar botones para puntos de referencia
            generarBotonesPuntosReferencia();
        }
        
        // Generar lista de años para el filtro
        generateYearOptions();
        
        // Mostrar predicciones
        renderPredictions();
    })
    .catch(error => {
        console.error('Error calculando predicciones:', error);
        prediccionesList.innerHTML = `
            <div class="alert alert-warning">
                <h5>Error al calcular predicciones</h5>
                <p>${error.message}</p>
                <p>Las predicciones requieren que el servidor esté configurado correctamente.</p>
                <button class="btn btn-outline-secondary mt-2" onclick="generarPrediccionesDemo()">Mostrar Ejemplo Demo</button>
            </div>
        `;
        
        // Al menos crear los botones de puntos de referencia por si fallan las predicciones
        if (Object.keys(puntosReferencia).length === 0) {
            puntosReferencia = {
                "ASCENDENTE": {
                    "descripcion": "Punto de la carta que representa el inicio de la primera casa."
                },
                "PARTE_FORTUNA": {
                    "descripcion": "Punto calculado en base a las posiciones del Sol, la Luna y el Ascendente."
                },
                "PARTE_ESPIRITU": {
                    "descripcion": "Punto inverso a la Parte de Fortuna, representa la conciencia y el espíritu."
                }
            };
            generarBotonesPuntosReferencia();
        }
    });
}

        // Función para generar botones de puntos de referencia
        function generarBotonesPuntosReferencia() {
            // Limpiar contenedor de botones
            puntosReferenciaBtns.innerHTML = '';
            
            // Añadir botón "Todos los puntos"
            const btnTodos = document.createElement('button');
            btnTodos.type = 'button';
            btnTodos.className = `btn btn-outline-primary punto-referencia-btn ${!puntoReferenciaSeleccionado ? 'active' : ''}`;
            btnTodos.dataset.punto = '';
            btnTodos.textContent = 'Todos los puntos';
            btnTodos.addEventListener('click', () => seleccionarPuntoReferencia(''));
            puntosReferenciaBtns.appendChild(btnTodos);
            
            // Añadir botones para cada punto de referencia
            for (const [punto, info] of Object.entries(puntosReferencia)) {
                const btn = document.createElement('button');
                btn.type = 'button';
                btn.className = `btn btn-outline-primary punto-referencia-btn ${puntoReferenciaSeleccionado === punto ? 'active' : ''}`;
                btn.dataset.punto = punto;
                btn.textContent = punto.replace('_', ' ').replace(/\b\w/g, l => l.toUpperCase());
                btn.addEventListener('click', () => seleccionarPuntoReferencia(punto));
                puntosReferenciaBtns.appendChild(btn);
            }
            
            // Mostrar información del punto seleccionado
            actualizarInfoPunto();
        }

        // Función para seleccionar un punto de referencia
        function seleccionarPuntoReferencia(punto) {
            // Actualizar variable global
            puntoReferenciaSeleccionado = punto;
            
            // Actualizar estado de botones
            document.querySelectorAll('.punto-referencia-btn').forEach(btn => {
                if (btn.dataset.punto === punto) {
                    btn.classList.add('active');
                } else {
                    btn.classList.remove('active');
                }
            });
            
            // Actualizar información del punto seleccionado
            actualizarInfoPunto();
            
            // Recalcular predicciones con el nuevo punto de referencia
            calculatePredictions();
        }

        // Función para actualizar la información del punto seleccionado
        function actualizarInfoPunto() {
            if (puntoReferenciaSeleccionado && puntosReferencia[puntoReferenciaSeleccionado]) {
                const info = puntosReferencia[puntoReferenciaSeleccionado];
                puntoInfo.innerHTML = `
                    <strong>${puntoReferenciaSeleccionado.replace('_', ' ').replace(/\b\w/g, l => l.toUpperCase())}</strong>: 
                    ${info.descripcion}
                `;
            } else {
                puntoInfo.innerHTML = 'Se mostrarán liberaciones desde todos los puntos de referencia.';
            }
        }

        // Función para generar opciones de años para el filtro
function generateYearOptions() {
    // Limpiar el select
    yearFilterSelect.innerHTML = '<option value="all">Todos los años</option>';
    
    // Recopilar todas las fechas de las predicciones
    const allDates = [
        ...predicciones.picosMayor.map(p => p.fecha),
        ...predicciones.picosModerado.map(p => p.fecha),
        ...predicciones.picosMenor.map(p => p.fecha),
        ...predicciones.liberaciones.map(p => p.fecha),
        ...predicciones.disoluciones.map(p => p.fecha)
    ];
    
    // Verificar si hay fechas para procesar
    if (allDates.length === 0) {
        console.log("No hay fechas de predicciones para generar opciones de años");
        return;
    }
    
    console.log("Fechas encontradas para generar opciones:", allDates);
    
    // Extraer los años únicos
    const years = new Set();
    allDates.forEach(fecha => {
        if (fecha && fecha.includes('-')) {
            const year = fecha.split('-')[0];
            years.add(year);
        } else {
            console.warn("Formato de fecha incorrecto:", fecha);
        }
    });
    
    // Ordenar años numéricamente
    const sortedYears = Array.from(years).sort((a, b) => parseInt(a) - parseInt(b));
    
    console.log("Años únicos encontrados:", sortedYears);
    
    // Agregar opciones al select
    sortedYears.forEach(year => {
        const option = document.createElement('option');
        option.value = year;
        option.textContent = year;
        yearFilterSelect.appendChild(option);
    });
    
    // Si no se agregaron años, mostrar mensaje
    if (sortedYears.length === 0) {
        const option = document.createElement('option');
        option.value = "";
        option.textContent = "No hay años disponibles";
        option.disabled = true;
        yearFilterSelect.appendChild(option);
    }
}

        // Función para renderizar predicciones
function renderPredictions() {
    // Obtener filtros seleccionados
    const yearFilter = yearFilterSelect.value;
    const tipoFilter = tipoPrediccionSelect.value;
    
    console.log("Renderizando predicciones con filtros:", yearFilter, tipoFilter);
    
    // Verificar si tenemos predicciones para renderizar
    const hayPicosMayor = predicciones.picosMayor && predicciones.picosMayor.length > 0;
    const hayPicosModerado = predicciones.picosModerado && predicciones.picosModerado.length > 0;
    const hayPicosMenor = predicciones.picosMenor && predicciones.picosMenor.length > 0;
    const hayLiberaciones = predicciones.liberaciones && predicciones.liberaciones.length > 0;
    const hayDisoluciones = predicciones.disoluciones && predicciones.disoluciones.length > 0;
    
    if (!hayPicosMayor && !hayPicosModerado && !hayPicosMenor && !hayLiberaciones && !hayDisoluciones) {
        prediccionesList.innerHTML = '<div class="alert alert-info">No hay predicciones disponibles. Por favor, calcule las predicciones primero.</div>';
        return;
    }
    
    // Recopilar todas las predicciones
    let allPredictions = [];
    
    // Picos Mayores
    if ((tipoFilter === 'all' || tipoFilter === 'pico-mayor') && hayPicosMayor) {
        predicciones.picosMayor.forEach(pico => {
            if (pico && pico.fecha) {
                allPredictions.push({
                    fecha: pico.fecha,
                    tipo: 'pico-mayor',
                    descripcion: `Pico Mayor: ${pico.planeta} con fuerza ${pico.fuerza}`,
                    planeta: pico.planeta,
                    fuerza: pico.fuerza,
                    punto: pico.punto,
                    angulo: pico.angulo,
                    signo: pico.signo || ""
                });
            }
        });
    }
    
    // Picos Moderados
    if ((tipoFilter === 'all' || tipoFilter === 'pico-moderado') && hayPicosModerado) {
        predicciones.picosModerado.forEach(pico => {
            if (pico && pico.fecha) {
                allPredictions.push({
                    fecha: pico.fecha,
                    tipo: 'pico-moderado',
                    descripcion: `Pico Moderado: ${pico.planeta} con fuerza ${pico.fuerza}`,
                    planeta: pico.planeta,
                    fuerza: pico.fuerza,
                    punto: pico.punto,
                    angulo: pico.angulo,
                    signo: pico.signo || ""
                });
            }
        });
    }
    
    // Picos Menores
    if ((tipoFilter === 'all' || tipoFilter === 'pico-menor') && hayPicosMenor) {
        predicciones.picosMenor.forEach(pico => {
            if (pico && pico.fecha) {
                allPredictions.push({
                    fecha: pico.fecha,
                    tipo: 'pico-menor',
                    descripcion: `Pico Menor: ${pico.planeta} con fuerza ${pico.fuerza}`,
                    planeta: pico.planeta,
                    fuerza: pico.fuerza,
                    punto: pico.punto,
                    angulo: pico.angulo,
                    signo: pico.signo || ""
                });
            }
        });
    }
    
    // Liberaciones
    if ((tipoFilter === 'all' || tipoFilter === 'liberacion') && hayLiberaciones) {
        predicciones.liberaciones.forEach(lib => {
            if (lib && lib.fecha) {
                allPredictions.push({
                    fecha: lib.fecha,
                    tipo: 'liberacion',
                    descripcion: `Liberación: ${lib.planeta_liberador} libera a ${lib.planeta_liberado} (${lib.punto || ''})`,
                    planeta_liberador: lib.planeta_liberador,
                    planeta_liberado: lib.planeta_liberado,
                    condicion: lib.condicion,
                    punto: lib.punto,
                    angulo: lib.angulo,
                    signo: lib.signo || ""
                });
            }
        });
    }
    
    // Disoluciones
    if ((tipoFilter === 'all' || tipoFilter === 'disolucion') && hayDisoluciones) {
        predicciones.disoluciones.forEach(dis => {
            if (dis && dis.fecha) {
                allPredictions.push({
                    fecha: dis.fecha,
                    tipo: 'disolucion',
                    descripcion: `Disolución: enlace entre ${dis.planeta1} y ${dis.planeta2}`,
                    planeta1: dis.planeta1,
                    planeta2: dis.planeta2,
                    signo: dis.signo || ""
                });
            }
        });
    }
    
    // Verificar si hay predicciones después de filtrar
    if (allPredictions.length === 0) {
        prediccionesList.innerHTML = '<div class="alert alert-info">No hay predicciones que coincidan con los filtros seleccionados.</div>';
        return;
    }
    
    console.log("Total de predicciones encontradas:", allPredictions.length);
    
    // Filtrar por año si es necesario
    if (yearFilter !== 'all') {
        allPredictions = allPredictions.filter(pred => pred.fecha && pred.fecha.startsWith(yearFilter));
        console.log(`Predicciones filtradas por año ${yearFilter}:`, allPredictions.length);
    }
    
    // Verificar si hay predicciones después de filtrar por año
    if (allPredictions.length === 0) {
        prediccionesList.innerHTML = '<div class="alert alert-info">No hay predicciones para el año seleccionado.</div>';
        return;
    }
    
    // Ordenar por fecha
    allPredictions.sort((a, b) => (a.fecha > b.fecha) ? 1 : -1);
    
    // Agrupar por año
    const predictionsByYear = {};
    allPredictions.forEach(pred => {
        if (!pred.fecha) return; // Ignorar predicciones sin fecha
        
        const year = pred.fecha.split('-')[0];
        if (!predictionsByYear[year])
            predictionsByYear[year] = [];
        predictionsByYear[year].push(pred);
    });
    
    // Generar HTML
    let html = '';
    Object.keys(predictionsByYear).sort().forEach(year => {
        html += `
            <div class="year-group" data-year="${year}">
                <div class="year-header" onclick="toggleYearGroup('${year}')">
                    ${year} <span class="badge bg-primary">${predictionsByYear[year].length}</span> <span class="float-end">▼</span>
                </div>
                <div class="year-content" id="year-content-${year}">
        `;
        
        predictionsByYear[year].forEach(pred => {
            try {
                const date = new Date(pred.fecha);
                const formattedDate = date.toLocaleDateString('es-ES', { 
                    day: '2-digit', 
                    month: 'long',
                    year: 'numeric'  // Agregamos el año para mayor claridad
                });
                
                // Añadimos más detalles a la descripción cuando tenemos ángulos y signos
                let detalles = '';
                if (pred.punto && pred.angulo) {
                    detalles = ` (${pred.punto}, ángulo ${pred.angulo}°)`;
                }
                if (pred.signo) {
                    detalles += ` en ${pred.signo}`;
                }
                
                html += `
                    <div class="prediccion-item prediccion-${pred.tipo}" data-fecha="${pred.fecha}" onclick="showTransitForDate('${pred.fecha}')">
                        <div class="prediccion-fecha">${formattedDate}</div>
                        <div>${pred.descripcion}${detalles}</div>
                    </div>
                `;
            } catch (e) {
                console.error("Error al formatear fecha:", pred.fecha, e);
                // Incluir un elemento con la información básica en caso de error
                html += `
                    <div class="prediccion-item prediccion-${pred.tipo}" data-fecha="${pred.fecha}" onclick="showTransitForDate('${pred.fecha}')">
                        <div class="prediccion-fecha">${pred.fecha}</div>
                        <div>${pred.descripcion}</div>
                    </div>
                `;
            }
        });
        
        html += `
                </div>
            </div>
        `;
    });
    
    prediccionesList.innerHTML = html;
    
    // Expandir el primer año por defecto
    const firstYearContent = document.getElementById(`year-content-${Object.keys(predictionsByYear).sort()[0]}`);
    if (firstYearContent) {
        firstYearContent.style.display = 'block';
    }
    
    console.log("Predicciones renderizadas correctamente");
}

        // Función para expandir/contraer grupos de años
        function toggleYearGroup(year) {
            const yearContent = document.getElementById(`year-content-${year}`);
            if (yearContent) {
                yearContent.style.display = yearContent.style.display === 'block' ? 'none' : 'block';
                
                // Actualizar el ícono
                const yearHeader = document.querySelector(`.year-group[data-year="${year}"] .year-header span.float-end`);
                if (yearHeader) {
                    yearHeader.textContent = yearContent.style.display === 'block' ? '▼' : '▶';
                }
            }
        }

        // Función para mostrar tránsitos para una fecha específica
        function showTransitForDate(fecha) {
            // Asegurarse de que tenemos una ciudad para los tránsitos
            if (!transitCityInput.value) {
                transitCityInput.value = cityInput.value; // Usar la misma ciudad que la carta natal
            }
            
            // Actualizar campos de fecha y hora de tránsito
            transitDateInput.value = fecha;
            transitTimeInput.value = '12:00'; // Usar mediodía por defecto
            
            // Activar el toggle de tránsitos si no está activo
            if (!showTransitsToggle.checked) {
                showTransitsToggle.checked = true;
                toggleTransits();
            }
            
            // Asegurarse que el análisis avanzado está activado
            if (!calculateAnalysisToggle.checked) {
                calculateAnalysisToggle.checked = true;
            }
            
            // Calcular tránsitos para esta fecha
            const transitCoords = getSelectedCityCoordinates(transitCityInput, transitCityList);
            
            // Mostrar loading
            loadingIndicator.style.display = 'flex';
            
            fetch('/calculate', {
                method: 'POST',
                headers: {
                    'Content-Type': 'application/json'
                },
                body: JSON.stringify({
                    city: transitCityInput.value,
                    date: fecha,
                    time: transitTimeInput.value,
                    lat: transitCoords.lat,
                    lon: transitCoords.lon,
                    calculateAnalysis: true // Siempre calcular análisis avanzado para los tránsitos
                })
            })
            .then(response => response.json())
            .then(data => {
                console.log("Datos de tránsito para fecha específica:", data);
                
                if (data.error) {
                    throw new Error(data.error);
                }
                
                // Actualizar tránsitos
                transitPlanets = data.positions;
                
                // Calcular aspectos entre cartas
                interChartAspects = calculateAspects(natalPlanets, transitPlanets);
                
                // Renderizar carta
                renderChart();
                
                // Hacer scroll hacia la carta
                chartContent.scrollIntoView({ behavior: 'smooth' });
            })
            .catch(error => {
                console.error('Error calculando tránsitos para fecha específica:', error);
                showError(`Error calculando tránsitos: ${error.message}`);
                loadingIndicator.style.display = 'none';
            });
        }

        // Función para calcular aspectos entre planetas
        function calculateAspects(planets1, planets2) {
            // Filtrar planetas tradicionales
            const traditionalPlanets = ["SOL", "LUNA", "MERCURIO", "VENUS", "MARTE", "JÚPITER", "SATURNO"];
            const validPlanets1 = planets1.filter(p => traditionalPlanets.includes(p.name));
            const validPlanets2 = planets2.filter(p => traditionalPlanets.includes(p.name));
            
            const aspects = [];
            const isSameChart = planets1 === planets2;
            
            for (let i = 0; i < validPlanets1.length; i++) {
                // Si es la misma carta, evitar aspectos duplicados
                const startJ = isSameChart ? i + 1 : 0;
                
                for (let j = startJ; j < validPlanets2.length; j++) {
                    const planet1 = validPlanets1[i];
                    const planet2 = validPlanets2[j];
                    
                    if (planet1 === planet2) continue;
                    
                    let diff = Math.abs(planet1.longitude - planet2.longitude);
                    if (diff > 180) diff = 360 - diff;
                    
                    // Comprobar aspectos importantes
                    for (const aspectType in ASPECTS) {
                        const aspect = ASPECTS[aspectType];
                        
                        if (Math.abs(diff - aspect.angle) <= aspect.orb) {
                            aspects.push({
                                planet1: planet1.name,
                                planet2: planet2.name,
                                type: aspectType,
                                angle: diff,
                                color: aspect.color,
                                isInterChart: !isSameChart,
                                fuerza: 0 // Se calculará en el backend si está disponible
                            });
                            break;
                        }
                    }
                }
            }
            
            return aspects;
        }

        // Modified renderChart function to include Relevo Zodiacal calculation
function renderChart() {
    console.log("Renderizando carta astral...");
    
    // Clear SVG
    chartSvg.innerHTML = '';
    
    // Draw elements
    drawZodiacWheel();
    drawAspects();
    drawPlanets(natalPlanets, true);
    
    if (showTransitsToggle.checked && transitPlanets.length > 0) {
        drawPlanets(transitPlanets, false);
    }
    
    // Update information lists
    updatePlanetsList();
    updateAspectsList();
    updateAdvancedInfo();
    
    // Show the chart
    chartContent.style.display = 'flex';
    
    // Hide loading
    loadingIndicator.style.display = 'none';

    // Calculate and display Relevo Zodiacal automatically
    calcularYMostrarRelevoZodiacal();
    
    console.log("Carta astral renderizada");
}

        // Función para dibujar la rueda zodiacal
        function drawZodiacWheel() {
            // Dibujar círculo exterior
            const outerCircle = createSvgElement('circle', {
                cx: DIMENSIONS.centerX,
                cy: DIMENSIONS.centerY,
                r: DIMENSIONS.radius,
                fill: 'none',
                stroke: '#333',
                'stroke-width': 2
            });
            chartSvg.appendChild(outerCircle);
            
            // Dibujar signos zodiacales
            SIGNS.forEach(sign => {
                const midAngle = ((sign.start + sign.length/2 - 90) * Math.PI) / 180;
                const glyphX = DIMENSIONS.centerX + DIMENSIONS.glyphRadius * Math.cos(midAngle);
                const glyphY = DIMENSIONS.centerY + DIMENSIONS.glyphRadius * Math.sin(midAngle);
                
                // Dibujar sector
                const path = createSvgElement('path', {
                    d: createArcPath(sign.start, sign.start + sign.length),
                    fill: sign.color,
                    stroke: '#333',
                    'stroke-width': 1
                });
                chartSvg.appendChild(path);
                
                // Añadir símbolo
                const text = createSvgElement('text', {
                    x: glyphX,
                    y: glyphY,
                    'text-anchor': 'middle',
                    'alignment-baseline': 'middle',
                    'font-size': 20
                });
                text.textContent = sign.symbol;
                chartSvg.appendChild(text);
            });
            
            // Dibujar círculo interior
            const innerCircle = createSvgElement('circle', {
                cx: DIMENSIONS.centerX,
                cy: DIMENSIONS.centerY,
                r: DIMENSIONS.innerRadius,
                fill: 'white',
                stroke: '#333',
                'stroke-width': 1
            });
            chartSvg.appendChild(innerCircle);
        }

        // Función para dibujar aspectos
        function drawAspects() {
            // Dibujar aspectos internos
            internalAspects.forEach((aspect, index) => {
                const planet1 = natalPlanets.find(p => p.name === aspect.planet1);
                const planet2 = natalPlanets.find(p => p.name === aspect.planet2);
                
                if (!planet1 || !planet2) return;
                
                const angle1 = (planet1.longitude - 90) * Math.PI / 180;
                const angle2 = (planet2.longitude - 90) * Math.PI / 180;
                
                const x1 = DIMENSIONS.centerX + DIMENSIONS.innerRadius * Math.cos(angle1);
                const y1 = DIMENSIONS.centerY + DIMENSIONS.innerRadius * Math.sin(angle1);
                const x2 = DIMENSIONS.centerX + DIMENSIONS.innerRadius * Math.cos(angle2);
                const y2 = DIMENSIONS.centerY + DIMENSIONS.innerRadius * Math.sin(angle2);
                
                const line = createSvgElement('line', {
                    x1: x1,
                    y1: y1,
                    x2: x2,
                    y2: y2,
                    stroke: aspect.color,
                    'stroke-width': selectedAspect === aspect ? '3' : '1',
                    'data-aspect-index': index,
                    'class': 'aspect-line internal-aspect'
                });
                
                line.addEventListener('click', () => {
                    selectAspect(aspect, 'internal');
                });
                
                line.addEventListener('mouseover', (e) => {
                    const aspectName = ASPECTS[aspect.type]?.name || aspect.type;
                    showTooltip(e, `${aspect.planet1} ${aspectName} ${aspect.planet2} (${aspect.angle.toFixed(1)}°)`);
                });
                
                line.addEventListener('mouseout', () => {
                    hideTooltip();
                });
                
                chartSvg.appendChild(line);
            });
            
            // Dibujar aspectos entre cartas
            if (showTransitsToggle.checked && transitPlanets.length > 0) {
                interChartAspects.forEach((aspect, index) => {
                    const planet1 = natalPlanets.find(p => p.name === aspect.planet1);
                    const planet2 = transitPlanets.find(p => p.name === aspect.planet2);
                    
                    if (!planet1 || !planet2) return;
                    
                    const angle1 = (planet1.longitude - 90) * Math.PI / 180;
                    const angle2 = (planet2.longitude - 90) * Math.PI / 180;
                    
                    const x1 = DIMENSIONS.centerX + DIMENSIONS.innerRadius * Math.cos(angle1);
                    const y1 = DIMENSIONS.centerY + DIMENSIONS.innerRadius * Math.sin(angle1);
                    const x2 = DIMENSIONS.centerX + DIMENSIONS.middleRadius * Math.cos(angle2);
                    const y2 = DIMENSIONS.centerY + DIMENSIONS.middleRadius * Math.sin(angle2);
                    
                    const line = createSvgElement('line', {
                        x1: x1,
                        y1: y1,
                        x2: x2,
                        y2: y2,
                        stroke: aspect.color,
                        'stroke-width': selectedAspect === aspect ? '3' : '1',
                        'stroke-dasharray': '3,3',
                        'data-aspect-index': index,
                        'class': 'aspect-line inter-aspect'
                    });
                    
                    line.addEventListener('click', () => {
                        selectAspect(aspect, 'inter');
                    });
                    
                    line.addEventListener('mouseover', (e) => {
                        const aspectName = ASPECTS[aspect.type]?.name || aspect.type;
                        showTooltip(e, `${aspect.planet1} ${aspectName} ${aspect.planet2} (${aspect.angle.toFixed(1)}°)`);
                    });
                    
                    line.addEventListener('mouseout', () => {
                        hideTooltip();
                    });
                    
                    chartSvg.appendChild(line);
                });
            }
        }

        // Función para determinar si un color es claro u oscuro
        function isLightColor(color) {
            // Si es un color en formato hexadecimal como "#RRGGBB"
            if (typeof color === 'string' && color.startsWith('#')) {
                const r = parseInt(color.slice(1, 3), 16);
                const g = parseInt(color.slice(3, 5), 16);
                const b = parseInt(color.slice(5, 7), 16);
                
                // Fórmula para calcular la luminosidad percibida
                // basada en recomendaciones de WCAG: https://www.w3.org/TR/WCAG20/
                const luminance = (0.299 * r + 0.587 * g + 0.114 * b) / 255;
                
                // Si la luminosidad es mayor a 0.5, consideramos el color como claro
                return luminance > 0.5;
            }
            
            // Para los colores predefinidos en COLORS
            if (color === COLORS.YELLOW || color === COLORS.GREEN) {
                return true; // Amarillo y verde son colores claros
            }
            
            return false; // Por defecto, consideramos el color como oscuro
        }

        // Función para dibujar planetas
        function drawPlanets(planets, isNatal) {
            const radius = isNatal ? DIMENSIONS.innerRadius : DIMENSIONS.middleRadius;
            
            // Definir colores pastel
            const PASTEL_COLORS = {
                RED: '#FF9999',       // Rojo pastel
                GREEN: '#99FF99',     // Verde pastel
                BLUE: '#9999FF',      // Azul pastel
                YELLOW: '#FFFF99',    // Amarillo pastel
                ORANGE: '#FFD699',    // Naranja pastel
                PURPLE: '#D699FF',    // Púrpura pastel
                CYAN: '#99FFFF',      // Cian pastel
                PINK: '#FF99FF',      // Rosa pastel
                GRAY: '#E0E0E0'       // Gris claro para puntos cardinales
            };
            
            planets.forEach((planet, index) => {
                // Calcular posición en el círculo
                const angle = (planet.longitude - 90) * Math.PI / 180;
                const x = DIMENSIONS.centerX + radius * Math.cos(angle);
                const y = DIMENSIONS.centerY + radius * Math.sin(angle);
                
                // Asignar colores pastel
                let planetColor;
                const longitude = planet.longitude;
                
                // Lógica de colores usando tonos pastel
                if (planet.name === 'ASC' || planet.name === 'MC' || planet.name === 'DSC' || planet.name === 'IC' ||
                    planet.name === 'PARTE_FORTUNA' || planet.name === 'PARTE_ESPIRITU') {
                    planetColor = PASTEL_COLORS.GRAY;  // Gris claro para puntos cardinales
                } else if (planet.name === 'JÚPITER') {
                    if ((longitude >= 306.00 && longitude <= 360.00) || (longitude >= 0.00 && longitude <= 150.00)) 
                        planetColor = PASTEL_COLORS.BLUE;
                    else if (longitude > 150.00 && longitude < 306.00) 
                        planetColor = PASTEL_COLORS.RED;
                    else
                        planetColor = PASTEL_COLORS.BLUE;
                } else if (planet.name === 'SATURNO') {
                    if ((longitude >= 330.00 && longitude <= 360.00) || (longitude >= 0.00 && longitude <= 150.00))
                        planetColor = PASTEL_COLORS.YELLOW;
                    else if (longitude > 240.00 && longitude <= 252.00) 
                        planetColor = PASTEL_COLORS.YELLOW;
                    else if (longitude > 252.00 && longitude <= 330.00) 
                        planetColor = PASTEL_COLORS.RED;
                    else if (longitude > 150.00 && longitude <= 240.00) 
                        planetColor = PASTEL_COLORS.RED;
                    else
                        planetColor = PASTEL_COLORS.YELLOW;
                } else if (longitude > 150.00 && longitude <= 330.00) {
                    if (planet.name === 'SOL' || planet.name === 'MERCURIO' || planet.name === 'URANO')
                        planetColor = PASTEL_COLORS.GREEN;
                    else if (planet.name === 'VENUS' || planet.name === 'LUNA')
                        planetColor = PASTEL_COLORS.YELLOW;
                    else if (planet.name === 'MARTE' || planet.name === 'PLUTÓN')
                        planetColor = PASTEL_COLORS.BLUE;
                    else if (planet.name === 'NEPTUNO')
                        planetColor = PASTEL_COLORS.RED;
                    else
                        planetColor = PASTEL_COLORS.GRAY;
                } else {
                    if (planet.name === 'SOL' || planet.name === 'MARTE' || planet.name === 'PLUTÓN')
                        planetColor = PASTEL_COLORS.RED;
                    else if (planet.name === 'VENUS')
                        planetColor = PASTEL_COLORS.GREEN;
                    else if (planet.name === 'MERCURIO' || planet.name === 'URANO')
                        planetColor = PASTEL_COLORS.YELLOW;
                    else if (planet.name === 'LUNA' || planet.name === 'NEPTUNO')
                        planetColor = PASTEL_COLORS.BLUE;
                    else
                        planetColor = PASTEL_COLORS.GRAY;
                }
                
                // Crear círculo para el planeta
                const circle = createSvgElement('circle', {
                    cx: x,
                    cy: y,
                    r: 12,
                    fill: planetColor, // Usar el color pastel
                    stroke: selectedPlanet === planet ? '#0000FF' : '#000000',
                    'stroke-width': selectedPlanet === planet ? 3 : 1,
                    'data-planet-index': index,
                    'data-is-natal': isNatal,
                    'class': 'planet-symbol'
                });
                
                // Añadir eventos al círculo
                circle.addEventListener('click', () => {
                    selectPlanet(planet, isNatal);
                });
                
                circle.addEventListener('mouseover', (e) => {
                    showTooltip(e, `${planet.name} en ${planet.sign} (${planet.longitude.toFixed(1)}°)`);
                });
                
                circle.addEventListener('mouseout', () => {
                    hideTooltip();
                });
                
                chartSvg.appendChild(circle);
                
                // Determinar estilo de texto según el planeta
                // Venus y Marte en negrita, resto normal
                if (planet.name === 'VENUS' || planet.name === 'MARTE') {
                    // Para Venus y Marte aplicamos un efecto de negrita más intenso
                    // Primero dibujamos un contorno grueso
                    const textOutline = createSvgElement('text', {
                        x: x,
                        y: y,
                        'text-anchor': 'middle',
                        'alignment-baseline': 'middle',
                        'font-size': 14,
                        'fill': '#000000',
                        'stroke': '#000000', 
                        'stroke-width': 1,  // Contorno más grueso para Venus y Marte
                        'font-weight': 'bold',
                        'pointer-events': 'none'
                    });
                    textOutline.textContent = PLANET_SYMBOLS[planet.name] || planet.name;
                    chartSvg.appendChild(textOutline);
                    
                    // Y luego el texto principal encima para un efecto más intenso
                    const textMain = createSvgElement('text', {
                        x: x,
                        y: y,
                        'text-anchor': 'middle',
                        'alignment-baseline': 'middle',
                        'font-size': 14,
                        'fill': '#000000',
                        'font-weight': 'bold',
                        'pointer-events': 'none'
                    });
                    textMain.textContent = PLANET_SYMBOLS[planet.name] || planet.name;
                    chartSvg.appendChild(textMain);
                } else {
                    // Para el resto de planetas, texto normal sin efecto de negrita adicional
                    const text = createSvgElement('text', {
                        x: x,
                        y: y,
                        'text-anchor': 'middle',
                        'alignment-baseline': 'middle',
                        'font-size': 14,
                        'fill': '#000000',
                        'font-weight': 'bold',  // Ya tiene negrita normal
                        'pointer-events': 'none'
                    });
                    text.textContent = PLANET_SYMBOLS[planet.name] || planet.name;
                    chartSvg.appendChild(text);
                }
            });
        }
        
        // Función para crear un elemento SVG
        function createSvgElement(type, attributes = {}) {
            const element = document.createElementNS('http://www.w3.org/2000/svg', type);
            
            for (const [key, value] of Object.entries(attributes)) {
                element.setAttribute(key, value);
            }
            
            return element;
        }

        // Función para crear un path de arco SVG
        function createArcPath(startAngle, endAngle) {
            // Convertir ángulos a radianes
            const startRad = (startAngle - 90) * Math.PI / 180;
            const endRad = (endAngle - 90) * Math.PI / 180;
            
            // Calcular puntos
            const startX = DIMENSIONS.centerX + DIMENSIONS.radius * Math.cos(startRad);
            const startY = DIMENSIONS.centerY + DIMENSIONS.radius * Math.sin(startRad);
            const endX = DIMENSIONS.centerX + DIMENSIONS.radius * Math.cos(endRad);
            const endY = DIMENSIONS.centerY + DIMENSIONS.radius * Math.sin(endRad);
            
            // Determinar flag de arco grande
            const largeArcFlag = endAngle - startAngle <= 180 ? '0' : '1';
            
            // Construir el string del path
            return `M ${DIMENSIONS.centerX} ${DIMENSIONS.centerY} L ${startX} ${startY} A ${DIMENSIONS.radius} ${DIMENSIONS.radius} 0 ${largeArcFlag} 1 ${endX} ${endY} Z`;
        }

        // Función para actualizar la lista de planetas
        function updatePlanetsList() {
            // Actualizar lista de planetas natales
            natalPlanetsContainer.innerHTML = '';
            
            natalPlanets.forEach(planet => {
                const planetItem = document.createElement('div');
                planetItem.className = `planet-list-item ${selectedPlanet === planet ? 'selected' : ''}`;
                
                // Determinar clase CSS para dignidad
                let dignityClass = '';
                if (planet.dignidad) {
                    dignityClass = `dignity-${planet.dignidad}`;
                }
                
                planetItem.innerHTML = `
                    <strong>${PLANET_SYMBOLS[planet.name] || planet.name}</strong>: 
                    ${planet.sign} ${planet.longitude.toFixed(1)}° 
                    <span class="${dignityClass}">${planet.dignidad ? `(${DIGNIDAD_LABELS[planet.dignidad]})` : ''}</span>
                `;
                
                planetItem.addEventListener('click', () => {
                    selectPlanet(planet, true);
                });
                
                natalPlanetsContainer.appendChild(planetItem);
            });
            
            // Actualizar lista de planetas de tránsito
            transitPlanetsContainer.innerHTML = '';
            
            if (showTransitsToggle.checked && transitPlanets.length > 0) {
                transitPlanets.forEach(planet => {
                    const planetItem = document.createElement('div');
                    planetItem.className = `planet-list-item ${selectedPlanet === planet ? 'selected' : ''}`;
                    
                    // Determinar clase CSS para dignidad
                    let dignityClass = '';
                    if (planet.dignidad) {
                        dignityClass = `dignity-${planet.dignidad}`;
                    }
                    
                    planetItem.innerHTML = `
                        <strong>${PLANET_SYMBOLS[planet.name] || planet.name}</strong>: 
                        ${planet.sign} ${planet.longitude.toFixed(1)}° 
                        <span class="${dignityClass}">${planet.dignidad ? `(${DIGNIDAD_LABELS[planet.dignidad]})` : ''}</span>
                    `;
                    
                    planetItem.addEventListener('click', () => {
                        selectPlanet(planet, false);
                    });
                    
                    transitPlanetsContainer.appendChild(planetItem);
                });
            } else {
                transitPlanetsContainer.innerHTML = '<p>No hay datos de tránsitos.</p>';
            }
        }

        // Función para actualizar la lista de aspectos
        function updateAspectsList() {
            // Actualizar aspectos internos
            internalAspectsContainer.innerHTML = '';
            
            if (internalAspects.length > 0) {
                internalAspects.forEach(aspect => {
                    const aspectItem = document.createElement('div');
                    aspectItem.className = `aspect-list-item ${selectedAspect === aspect ? 'selected' : ''}`;
                    
                    const aspectName = ASPECTS[aspect.type]?.name || aspect.type;
                    const aspectStrength = aspect.fuerza ? ` (Fuerza: ${aspect.fuerza.toFixed(1)})` : '';
                    
                    aspectItem.innerHTML = `
                        <strong>${PLANET_SYMBOLS[aspect.planet1] || aspect.planet1}</strong> 
                        <span style="color: ${ASPECTS[aspect.type].color};">${aspectName}</span> 
                        <strong>${PLANET_SYMBOLS[aspect.planet2] || aspect.planet2}</strong>
                        ${aspectStrength}
                    `;
                    
                    aspectItem.addEventListener('click', () => {
                        selectAspect(aspect, 'internal');
                    });
                    
                    internalAspectsContainer.appendChild(aspectItem);
                });
            } else {
                internalAspectsContainer.innerHTML = '<p>No hay aspectos internos.</p>';
            }
            
            // Actualizar aspectos entre cartas
            interChartAspectsContainer.innerHTML = '';
            
            if (showTransitsToggle.checked && interChartAspects.length > 0) {
                interChartAspects.forEach(aspect => {
                    const aspectItem = document.createElement('div');
                    aspectItem.className = `aspect-list-item ${selectedAspect === aspect ? 'selected' : ''}`;
                    
                    const aspectName = ASPECTS[aspect.type]?.name || aspect.type;
                    
                    aspectItem.innerHTML = `
                        <strong>${PLANET_SYMBOLS[aspect.planet1] || aspect.planet1}</strong> (natal)
                        <span style="color: ${ASPECTS[aspect.type].color};">${aspectName}</span> 
                        <strong>${PLANET_SYMBOLS[aspect.planet2] || aspect.planet2}</strong> (tránsito)
                    `;
                    
                    aspectItem.addEventListener('click', () => {
                        selectAspect(aspect, 'inter');
                    });
                    
                    interChartAspectsContainer.appendChild(aspectItem);
                });
            } else {
                interChartAspectsContainer.innerHTML = '<p>No hay aspectos entre cartas.</p>';
            }
        }

        // Función para actualizar información avanzada
        function updateAdvancedInfo() {
            // Solo actualizar si calculateAnalysis está activado
            if (!calculateAnalysisToggle.checked) {
                enlacesPlanetariosContainer.innerHTML = '<p>Activa "Análisis Avanzado" para ver esta información.</p>';
                picoMayorContainer.innerHTML = '';
                picoModeradoContainer.innerHTML = '';
                picoMenorContainer.innerHTML = '';
                liberacionEnlaceContainer.innerHTML = '';
                presagiosContainer.innerHTML = '';
                return;
            }
            
            // Enlaces planetarios
            enlacesPlanetariosContainer.innerHTML = '';
            if (enlaces && enlaces.length > 0) {
                enlaces.forEach(enlace => {
                    const enlaceItem = document.createElement('div');
                    
                    // Determinar clase de fuerza
                    let fuerzaClass = 'enlace-medio';
                    if (enlace.fuerza >= 8) fuerzaClass = 'enlace-fuerte';
                    else if (enlace.fuerza <= 3) fuerzaClass = 'enlace-debil';
                    
                    enlaceItem.className = `enlace-item ${fuerzaClass}`;
                    
                    enlaceItem.innerHTML = `
                        <strong>${PLANET_SYMBOLS[enlace.planeta1] || enlace.planeta1}</strong> →
                        <strong>${PLANET_SYMBOLS[enlace.planeta2] || enlace.planeta2}</strong>
                        (Fuerza: ${enlace.fuerza})
                        ${enlace.disolucion ? '<span class="badge bg-warning">Disuelto</span>' : ''}
                    `;
                    
                    enlacesPlanetariosContainer.appendChild(enlaceItem);
                });
            } else {
                enlacesPlanetariosContainer.innerHTML = '<p>No hay enlaces planetarios significativos.</p>';
            }
            
            // Picos
            picoMayorContainer.innerHTML = '';
            if (window.pico_mayor && window.pico_mayor.length > 0) {
                window.pico_mayor.forEach(pico => {
                    const picoItem = document.createElement('div');
                    picoItem.className = 'pico-item';
                    
                    picoItem.innerHTML = `
                        <strong>${PLANET_SYMBOLS[pico.planeta] || pico.planeta}</strong>
                        en ${pico.signo} con fuerza ${pico.fuerza}
                        ${pico.planetas_aspectados ? `<br>Aspectos favorables con: ${pico.planetas_aspectados.join(', ')}` : ''}
                    `;
                    
                    picoMayorContainer.appendChild(picoItem);
                });
            } else {
                picoMayorContainer.innerHTML = '<p>No hay picos mayores.</p>';
            }
            
            // Repetir similar para pico moderado y menor
            picoModeradoContainer.innerHTML = '';
            if (window.pico_moderado && window.pico_moderado.length > 0) {
                // Similar a picoMayor
                window.pico_moderado.forEach(pico => {
                    const picoItem = document.createElement('div');
                    picoItem.className = 'pico-item';
                    
                    picoItem.innerHTML = `
                        <strong>${PLANET_SYMBOLS[pico.planeta] || pico.planeta}</strong>
                        en ${pico.signo} con fuerza ${pico.fuerza}
                        ${pico.planetas_aspectados ? `<br>Aspectos favorables con: ${pico.planetas_aspectados.join(', ')}` : ''}
                    `;
                    
                    picoModeradoContainer.appendChild(picoItem);
                });
            } else {
                picoModeradoContainer.innerHTML = '<p>No hay picos moderados.</p>';
            }
            
            picoMenorContainer.innerHTML = '';
            if (window.pico_menor && window.pico_menor.length > 0) {
                // Similar a picoMayor
                window.pico_menor.forEach(pico => {
                    const picoItem = document.createElement('div');
                    picoItem.className = 'pico-item';
                    
                    picoItem.innerHTML = `
                        <strong>${PLANET_SYMBOLS[pico.planeta] || pico.planeta}</strong>
                        en ${pico.signo} con fuerza ${pico.fuerza}
                        ${pico.planetas_aspectados ? `<br>Aspectos favorables con: ${pico.planetas_aspectados.join(', ')}` : ''}
                    `;
                    
                    picoMenorContainer.appendChild(picoItem);
                });
            } else {
                picoMenorContainer.innerHTML = '<p>No hay picos menores.</p>';
            }
            
            // Liberación de enlace
            liberacionEnlaceContainer.innerHTML = '';
            if (window.liberacion_enlace && window.liberacion_enlace.length > 0) {
                window.liberacion_enlace.forEach(liberacion => {
                    const libItem = document.createElement('div');
                    libItem.className = 'enlace-item enlace-fuerte';
                    
                    libItem.innerHTML = `
                        <strong>${PLANET_SYMBOLS[liberacion.planeta_liberador] || liberacion.planeta_liberador}</strong>
                        libera a
                        <strong>${PLANET_SYMBOLS[liberacion.planeta_liberado] || liberacion.planeta_liberado}</strong>
                        mediante ${liberacion.condicion}
                    `;
                    
                    liberacionEnlaceContainer.appendChild(libItem);
                });
            } else {
                liberacionEnlaceContainer.innerHTML = '<p>No hay liberaciones de enlace.</p>';
            }
            
            // Presagios
            presagiosContainer.innerHTML = '';
            let hasPresagios = false;
            
            if (window.presagios?.buenos && window.presagios.buenos.length > 0) {
                hasPresagios = true;
                const presagiosBuenosTitle = document.createElement('h5');
                presagiosBuenosTitle.textContent = 'Presagios Favorables';
                presagiosContainer.appendChild(presagiosBuenosTitle);
                
                window.presagios.buenos.forEach(presagio => {
                    const presItem = document.createElement('div');
                    presItem.className = 'enlace-item enlace-fuerte';
                    
                    presItem.innerHTML = `
                        <strong>${PLANET_SYMBOLS[presagio.planeta] || presagio.planeta}</strong>
                        en ${presagio.signo}
                        ${presagio.aspectos ? `con aspectos favorables` : ''}
                    `;
                    
                    presagiosContainer.appendChild(presItem);
                });
            }
            
            if (window.presagios?.malos && window.presagios.malos.length > 0) {
                hasPresagios = true;
                const presagiosMalosTitle = document.createElement('h5');
                presagiosMalosTitle.textContent = 'Presagios Desfavorables';
                presagiosMalosTitle.className = 'mt-3';
                presagiosContainer.appendChild(presagiosMalosTitle);
                
                window.presagios.malos.forEach(presagio => {
                    const presItem = document.createElement('div');
                    presItem.className = 'enlace-item enlace-debil';
                    
                    presItem.innerHTML = `
                        <strong>${PLANET_SYMBOLS[presagio.planeta] || presagio.planeta}</strong>
                        en ${presagio.signo}
                        ${presagio.aspectos ? `con aspectos desfavorables` : ''}
                    `;
                    
                    presagiosContainer.appendChild(presItem);
                });
            }
            
            if (!hasPresagios) {
                presagiosContainer.innerHTML = '<p>No hay presagios significativos.</p>';
            }
        }

        // Función para seleccionar un planeta
        function selectPlanet(planet, isNatal) {
            // Deseleccionar aspecto si hay alguno
            selectedAspect = null;
            
            // Alternar selección
            if (selectedPlanet === planet) {
                selectedPlanet = null;
            } else {
                selectedPlanet = planet;
            }
            
            // Volver a renderizar la carta para mostrar la selección
            renderChart();
        }

        // Función para seleccionar un aspecto
        function selectAspect(aspect, type) {
            // Deseleccionar planeta si hay alguno
            selectedPlanet = null;
            
            // Alternar selección
            if (selectedAspect === aspect) {
                selectedAspect = null;
            } else {
                selectedAspect = aspect;
            }
            
            // Volver a renderizar la carta para mostrar la selección
            renderChart();
        }

        // Función para obtener signo a partir de longitud (utilidad)
        function getSignFromLongitude(longitude) {
            longitude = longitude % 360;
            
            for (const sign of SIGNS) {
                if (sign.name === "ARIES") {
                    // Caso especial para Aries que cruza el 0°
                    if (longitude >= sign.start || longitude < (sign.start + sign.length) % 360) {
                        return sign.name;
                    }
                } else if (longitude >= sign.start && longitude < sign.start + sign.length) {
                    return sign.name;
                }
            }
            
            return "ARIES"; // Por defecto
        }

       // Función mejorada para generar la secuencia de signos
function generarSecuencia(inicio) {
    console.log("Generando secuencia a partir de:", inicio);
    
    // Lista base de signos en orden
    const signos = Object.keys(DURACION_POR_NIVEL);
    
    // Verificar que el inicio es una cadena de texto
    if (typeof inicio !== 'string') {
        console.error("ERROR: El inicio debe ser una cadena de texto, se recibió:", typeof inicio);
        // Usar 'aries' como valor predeterminado
        inicio = 'aries';
    }
    
    // Normalizar el signo inicial (convertir a minúsculas, quitar acentos)
    const inicioNormalizado = inicio.toLowerCase()
        .replace('á', 'a')
        .replace('é', 'e')
        .replace('í', 'i')
        .replace('ó', 'o')
        .replace('ú', 'u');
    
    // Mapeo ampliado de nombres de signos para mayor compatibilidad
    const signoMap = {
        'aries': 'aries',
        'tauro': 'tauro',
        'taurus': 'tauro',
        'géminis': 'geminis',
        'geminis': 'geminis',
        'gemini': 'geminis',
        'cáncer': 'cancer',
        'cancer': 'cancer',
        'canc': 'cancer',
        'leo': 'leo',
        'virgo': 'virgo',
        'vir': 'virgo',
        'libra': 'libra',
        'lib': 'libra',
        'escorpio': 'escorpio',
        'escorpión': 'escorpio',
        'scorpio': 'escorpio',
        'scorp': 'escorpio',
        'ofiuco': 'ofiuco',
        'ophiuchus': 'ofiuco',
        'sagitario': 'sagitario',
        'sagittarius': 'sagitario',
        'sag': 'sagitario',
        'capricornio': 'capricornio',
        'capricorn': 'capricornio',
        'cap': 'capricornio',
        'acuario': 'acuario',
        'aquarius': 'acuario',
        'aqu': 'acuario',
        'piscis': 'piscis',
        'pisces': 'piscis',
        'pis': 'piscis'
    };
    
    // También normalizar desde nombres de signos en mayúsculas
    const signosMayusculas = {
        'ARIES': 'aries',
        'TAURO': 'tauro',
        'TAURUS': 'tauro',
        'GÉMINIS': 'geminis',
        'GEMINIS': 'geminis',
        'GEMINI': 'geminis',
        'CÁNCER': 'cancer',
        'CANCER': 'cancer',
        'LEO': 'leo',
        'VIRGO': 'virgo',
        'LIBRA': 'libra',
        'ESCORPIO': 'escorpio',
        'SCORPIO': 'escorpio',
        'OFIUCO': 'ofiuco',
        'OPHIUCHUS': 'ofiuco',
        'SAGITARIO': 'sagitario',
        'SAGITTARIUS': 'sagitario',
        'CAPRICORNIO': 'capricornio',
        'CAPRICORN': 'capricornio',
        'ACUARIO': 'acuario',
        'AQUARIUS': 'acuario',
        'PISCIS': 'piscis',
        'PISCES': 'piscis'
    };
    
    // Intentar encontrar el signo normalizado
    let inicioMapeado = signoMap[inicioNormalizado] || signosMayusculas[inicio] || inicioNormalizado;
    
    // Buscar la posición del signo inicial en la lista
    let pos = signos.indexOf(inicioMapeado);
    
    if (pos === -1) {
        console.error(`ERROR: Signo "${inicio}" (normalizado como "${inicioMapeado}") no encontrado en la lista de signos.`);
        console.log("Signos disponibles:", signos);
        console.log("Usando 'aries' como valor predeterminado.");
        
        // Si no se encuentra el signo, usar aries como predeterminado
        pos = signos.indexOf('aries');
        
        // Si por alguna razón 'aries' tampoco se encuentra, usar el primer signo de la lista
        if (pos === -1) {
            pos = 0;
            console.error("ERROR crítico: 'aries' no encontrado en lista de signos. Usando el primero disponible:", signos[0]);
        }
    }
    
    // Generar la secuencia rotando la lista desde el signo inicial
    const secuencia = signos.slice(pos).concat(signos.slice(0, pos));
    return secuencia;
}
        
function calcularYMostrarRelevoZodiacal() {
    console.log("Calculando y mostrando Relevo Zodiacal con punto de referencia seleccionado");
    
    // Verificar si existe el contenedor
    if (!relevoZodiacalContainer) {
        console.log("Contenedor Relevo Zodiacal no encontrado");
        return;
    }
    
    // Verificar si tenemos los datos necesarios (planetas natales)
    if (!natalPlanets || natalPlanets.length === 0) {
        relevoZodiacalContainer.innerHTML = '<div class="alert alert-warning">No se encontraron datos de carta natal. Por favor, calcule la carta primero.</div>';
        return;
    }
    
    // Obtener fecha de nacimiento y fecha de tránsito
    const transitDate = transitDateInput ? transitDateInput.value : null;
    
    if (!transitDate) {
        relevoZodiacalContainer.innerHTML = '<div class="alert alert-warning">No se encontró fecha de tránsito. Por favor, seleccione una fecha.</div>';
        return;
    }
    
    if (!birthDate) {
        relevoZodiacalContainer.innerHTML = '<div class="alert alert-warning">No se pudo determinar la fecha de nacimiento.</div>';
        return;
    }
    
    // Obtener el punto de referencia seleccionado de los botones de radio
    const puntoReferenciaElements = document.getElementsByName("puntoReferenciaRelevo");
    let puntoReferencia = "ASC"; // Por defecto usar ASC
    
    for (const radio of puntoReferenciaElements) {
        if (radio.checked) {
            puntoReferencia = radio.value;
            break;
        }
    }
    
    // Encontrar el signo del punto de referencia seleccionado
    let puntoSigno = null;
    const puntoReferenciaPlanet = natalPlanets.find(p => p.name === puntoReferencia);
    
    if (!puntoReferenciaPlanet) {
        relevoZodiacalContainer.innerHTML = '<div class="alert alert-warning">Punto de referencia seleccionado no encontrado en la carta.</div>';
        return;
    }
    
    puntoSigno = puntoReferenciaPlanet.sign;
    console.log(`Calculando Relevo para: ${puntoReferencia} en ${puntoSigno}`);
    
    // Mostrar mensaje de carga
    relevoZodiacalContainer.innerHTML = `<div class="alert alert-info">Calculando Relevo Zodiacal para ${puntoReferencia.replace('_', ' ')} en ${puntoSigno}...</div>`;
    
    try {
        // Normalizar el signo para usarlo en la secuencia
        let signoNormalizado = puntoSigno.toLowerCase();
        
        // Conversión de nombres de signos en inglés a español para la secuencia
        const conversionSignos = {
            'ARIES': 'aries',
            'TAURUS': 'tauro',
            'GEMINI': 'geminis',
            'CANCER': 'cancer',
            'LEO': 'leo',
            'VIRGO': 'virgo',
            'LIBRA': 'libra',
            'SCORPIO': 'escorpio',
            'OPHIUCHUS': 'ofiuco',
            'SAGITTARIUS': 'sagitario',
            'CAPRICORN': 'capricornio',
            'AQUARIUS': 'acuario',
            'PISCES': 'piscis'
        };
        
        signoNormalizado = conversionSignos[puntoSigno] || signoNormalizado;
        
        // Calcular periodos del Relevo Zodiacal con el punto de referencia seleccionado
        const periodosActivos = calcularRelevoZodiacal(birthDate, signoNormalizado, transitDate);
        
        if (!periodosActivos || periodosActivos.length === 0) {
            relevoZodiacalContainer.innerHTML = '<div class="alert alert-warning">No se encontraron períodos activos para la fecha seleccionada.</div>';
            return;
        }
        
        // Generar HTML para los periodos
        let html = '';
        
        html += `<div class="alert alert-info">Relevo Zodiacal calculado usando ${puntoReferencia.replace('_', ' ')} en ${puntoSigno}</div>`;
        
        periodosActivos.forEach(periodo => {
            // Obtener información del elemento para el signo
            let elementoInfo = ELEMENTOS_SIGNOS[SIGNOS_NORMALIZADOS[periodo.signo]] || {
                elemento: 'Neutral',
                color: '#f8f9fa',
                borde: '#6c757d'
            };
            
            // Determinar clase para el elemento
            let elementoClass = '';
            if (periodo.signo) {
                const signoNorm = periodo.signo.toLowerCase();
                if (['aries', 'leo', 'sagitario'].includes(signoNorm)) {
                    elementoClass = 'fuego';
                } else if (['tauro', 'virgo', 'capricornio'].includes(signoNorm)) {
                    elementoClass = 'tierra';
                } else if (['geminis', 'libra', 'acuario', 'ofiuco'].includes(signoNorm)) {
                    elementoClass = 'aire';
                } else if (['cancer', 'escorpio', 'piscis'].includes(signoNorm)) {
                    elementoClass = 'agua';
                }
            }
            
            html += `
                <div class="relevo-periodo ${elementoClass}">
                    <h5>${periodo.signo.charAt(0).toUpperCase() + periodo.signo.slice(1)} - ${periodo.regente}</h5>
                    <p>
                        Período: ${periodo.fechaInicio} - ${periodo.fechaFin}
                        <br>
                        Edad: ${periodo.edad} años
                    </p>
            `;
            
            if (periodo.subperiodos && periodo.subperiodos.length > 0) {
                periodo.subperiodos.forEach(subp => {
                    // Obtener clase para subperiodo
                    let subElementoClass = '';
                    if (subp.signo) {
                        const signoNorm = subp.signo.toLowerCase();
                        if (['aries', 'leo', 'sagitario'].includes(signoNorm)) {
                            subElementoClass = 'fuego';
                        } else if (['tauro', 'virgo', 'capricornio'].includes(signoNorm)) {
                            subElementoClass = 'tierra';
                        } else if (['geminis', 'libra', 'acuario', 'ofiuco'].includes(signoNorm)) {
                            subElementoClass = 'aire';
                        } else if (['cancer', 'escorpio', 'piscis'].includes(signoNorm)) {
                            subElementoClass = 'agua';
                        }
                    }
                    
                    html += `
                        <div class="relevo-subperiodo ${subElementoClass}">
                            <h6>${subp.signo.charAt(0).toUpperCase() + subp.signo.slice(1)} - ${subp.regente}</h6>
                            <p>
                                Subperíodo: ${subp.fechaInicio} - ${subp.fechaFin}
                                <br>
                                Edad: ${subp.edad} años
                            </p>
                    `;
                    
                    if (subp.subperiodos && subp.subperiodos.length > 0) {
                        subp.subperiodos.forEach(subsubp => {
                            // Obtener clase para sub-subperiodo
                            let subsubElementoClass = '';
                            if (subsubp.signo) {
                                const signoNorm = subsubp.signo.toLowerCase();
                                if (['aries', 'leo', 'sagitario'].includes(signoNorm)) {
                                    subsubElementoClass = 'fuego';
                                } else if (['tauro', 'virgo', 'capricornio'].includes(signoNorm)) {
                                    subsubElementoClass = 'tierra';
                                } else if (['geminis', 'libra', 'acuario', 'ofiuco'].includes(signoNorm)) {
                                    subsubElementoClass = 'aire';
                                } else if (['cancer', 'escorpio', 'piscis'].includes(signoNorm)) {
                                    subsubElementoClass = 'agua';
                                }
                            }
                            
                            html += `
                                <div class="relevo-subsubperiodo ${subsubElementoClass}">
                                    <h6>${subsubp.signo.charAt(0).toUpperCase() + subsubp.signo.slice(1)} - ${subsubp.regente}</h6>
                                    <p>
                                        Sub-subperíodo: ${subsubp.fechaInicio} - ${subsubp.fechaFin}
                                        <br>
                                        Edad: ${subsubp.edad} años
                                    </p>
                                </div>
                            `;
                        });
                    }
                    
                    html += `</div>`;
                });
            }
            
            html += `</div>`;
        });
        
        relevoZodiacalContainer.innerHTML = html;
        console.log("Relevo Zodiacal mostrado exitosamente");
        
    } catch (error) {
        console.error("Error calculando Relevo Zodiacal:", error);
        relevoZodiacalContainer.innerHTML = `<div class="alert alert-danger">Error calculando el Relevo Zodiacal: ${error.message}</div>`;
    }
}
        
// Helper function to calculate the Zodiacal Relay
// Fixed to start from the birth date instead of January 1st
function calcularRelevoZodiacal(birthDate, ascendente, transitDate) {
    // Convertir fechas a objetos Date
    const fechaNac = new Date(birthDate);
    const fechaTransito = new Date(transitDate);
    
    // Generar secuencia de signos a partir del punto de referencia
    const secuencia = generarSecuencia(ascendente);
    console.log("Secuencia de signos generada:", secuencia);
    
    // Periodos activos para la fecha de tránsito
    const periodosActivos = [];
    let diaActual = 0;
    
    // Mapeo de elementos para signos
    const elementosSignos = {
        'aries': 'Fuego',
        'leo': 'Fuego',
        'sagitario': 'Fuego',
        'tauro': 'Tierra',
        'virgo': 'Tierra',
        'capricornio': 'Tierra',
        'geminis': 'Aire',
        'libra': 'Aire',
        'acuario': 'Aire',
        'ofiuco': 'Aire',
        'cancer': 'Agua',
        'escorpio': 'Agua',
        'piscis': 'Agua'
    };
    
    // Regentes planetarios para cada signo
    const regentesSignos = {
        'aries': 'Marte',
        'tauro': 'Venus',
        'geminis': 'Mercurio',
        'cancer': 'Luna',
        'leo': 'Sol',
        'virgo': 'Mercurio',
        'libra': 'Venus',
        'escorpio': 'Marte',
        'ofiuco': 'Saturno',
        'sagitario': 'Júpiter',
        'capricornio': 'Sol',
        'acuario': 'Luna',
        'piscis': 'Júpiter'
    };
    
    // Para cada signo en la secuencia, calcular su periodo
    for (let i = 0; i < secuencia.length; i++) {
        const signo = secuencia[i];
        const anios = DURACION_POR_NIVEL[signo];
        const diasEnPeriodo = anios * DURACIONES.AÑO;
        
        // Calcular fecha de inicio y fin del periodo
        // Importante: Iniciar exactamente desde la fecha de nacimiento, no desde el 1 de enero
        const fechaInicio = new Date(fechaNac);
        fechaInicio.setDate(fechaInicio.getDate() + diaActual);
        
        const fechaFin = new Date(fechaInicio);
        fechaFin.setDate(fechaInicio.getDate() + diasEnPeriodo);
        
        // Comprobar si la fecha de tránsito está dentro de este periodo
        if (fechaTransito >= fechaInicio && fechaTransito <= fechaFin) {
            // Calcular edad para este periodo
            const edad = calcularEdad(fechaNac, fechaInicio);
            
            // Crear objeto de periodo principal
            const periodo = {
                signo: signo,
                nivel: 1,
                fechaInicio: fechaInicio.toLocaleDateString('es-ES'),
                fechaFin: fechaFin.toLocaleDateString('es-ES'),
                edad: edad,
                regente: regentesSignos[signo] || 'Desconocido',
                elemento: elementosSignos[signo] || 'Neutral',
                subperiodos: []
            };
            
            // Calcular subperiodos (meses)
            const subSecuencia = generarSecuencia(signo);
            let diaInicioSub = diaActual;
            
            for (let j = 0; j < subSecuencia.length; j++) {
                const subSigno = subSecuencia[j];
                const meses = DURACION_POR_NIVEL[subSigno];
                const diasEnSubperiodo = meses * DURACIONES.MES;
                
                // Calcular fecha de inicio y fin del subperiodo
                const fechaInicioSub = new Date(fechaNac);
                fechaInicioSub.setDate(fechaInicioSub.getDate() + diaInicioSub);
                
                const fechaFinSub = new Date(fechaInicioSub);
                fechaFinSub.setDate(fechaInicioSub.getDate() + diasEnSubperiodo);
                
                // Asegurarse de que no exceda la fecha fin del periodo principal
                if (fechaFinSub > fechaFin) {
                    fechaFinSub.setTime(fechaFin.getTime());
                }
                
                // Comprobar si la fecha de tránsito está dentro de este subperiodo
                if (fechaTransito >= fechaInicioSub && fechaTransito <= fechaFinSub) {
                    // Calcular edad para este subperiodo
                    const edadSub = calcularEdad(fechaNac, fechaInicioSub);
                    
                    // Crear objeto de subperiodo
                    const subperiodo = {
                        signo: subSigno,
                        nivel: 2,
                        fechaInicio: fechaInicioSub.toLocaleDateString('es-ES'),
                        fechaFin: fechaFinSub.toLocaleDateString('es-ES'),
                        edad: edadSub,
                        regente: regentesSignos[subSigno] || 'Desconocido',
                        elemento: elementosSignos[subSigno] || 'Neutral',
                        subperiodos: []
                    };
                    
                    // Calcular sub-subperiodos (semanas)
                    const subSubSecuencia = generarSecuencia(subSigno);
                    let diaInicioSubSub = diaInicioSub;
                    
                    for (let k = 0; k < subSubSecuencia.length; k++) {
                        const subSubSigno = subSubSecuencia[k];
                        const semanas = DURACION_POR_NIVEL[subSubSigno];
                        const diasEnSubSubperiodo = semanas * DURACIONES.SEMANA;
                        
                        // Calcular fecha de inicio y fin del sub-subperiodo
                        const fechaInicioSubSub = new Date(fechaNac);
                        fechaInicioSubSub.setDate(fechaInicioSubSub.getDate() + diaInicioSubSub);
                        
                        const fechaFinSubSub = new Date(fechaInicioSubSub);
                        fechaFinSubSub.setDate(fechaInicioSubSub.getDate() + diasEnSubSubperiodo);
                        
                        // Asegurarse de que no exceda la fecha fin del subperiodo
                        if (fechaFinSubSub > fechaFinSub) {
                            fechaFinSubSub.setTime(fechaFinSub.getTime());
                        }
                        
                        // Comprobar si la fecha de tránsito está dentro de este sub-subperiodo
                        if (fechaTransito >= fechaInicioSubSub && fechaTransito <= fechaFinSubSub) {
                            // Calcular edad para este sub-subperiodo
                            const edadSubSub = calcularEdad(fechaNac, fechaInicioSubSub);
                            
                            // Crear objeto de sub-subperiodo
                            const subSubperiodo = {
                                signo: subSubSigno,
                                nivel: 3,
                                fechaInicio: fechaInicioSubSub.toLocaleDateString('es-ES'),
                                fechaFin: fechaFinSubSub.toLocaleDateString('es-ES'),
                                edad: edadSubSub,
                                regente: regentesSignos[subSubSigno] || 'Desconocido',
                                elemento: elementosSignos[subSubSigno] || 'Neutral'
                            };
                            
                            // Añadir sub-subperiodo al subperiodo
                            subperiodo.subperiodos.push(subSubperiodo);
                        }
                        
                        // Avanzar el día de inicio para el siguiente sub-subperiodo
                        diaInicioSubSub += diasEnSubSubperiodo;
                        
                        // Si hemos sobrepasado el fin del subperiodo, salir del bucle
                        if (diaInicioSubSub >= diaInicioSub + diasEnSubperiodo || 
                            new Date(fechaNac.getTime() + diaInicioSubSub * 24 * 60 * 60 * 1000) > fechaFinSub) {
                            break;
                        }
                    }
                    
                    // Añadir subperiodo al periodo principal
                    periodo.subperiodos.push(subperiodo);
                }
                
                // Avanzar el día de inicio para el siguiente subperiodo
                diaInicioSub += diasEnSubperiodo;
                
                // Si hemos sobrepasado el fin del periodo principal, salir del bucle
                if (diaInicioSub >= diaActual + diasEnPeriodo || 
                    new Date(fechaNac.getTime() + diaInicioSub * 24 * 60 * 60 * 1000) > fechaFin) {
                    break;
                }
            }
            
            // Añadir el periodo a la lista de periodos activos
            periodosActivos.push(periodo);
        }
        
        // Avanzar al siguiente periodo principal
        diaActual += diasEnPeriodo;
    }
    
    return periodosActivos;
}
        
// Helper function to calculate the Zodiacal Relay
function calcularRelevoZodiacal(birthDate, ascendente, transitDate) {
    // Convert dates to Date objects
    const fechaNac = new Date(birthDate);
    const fechaTransito = new Date(transitDate);
    
    // Generate sign sequence from the reference point
    const secuencia = generarSecuencia(ascendente);
    console.log("Generated sign sequence:", secuencia);
    
    // Active periods for the transit date
    const periodosActivos = [];
    let diaActual = 0;
    
    // Element mapping for signs
    const elementosSignos = {
        'aries': 'Fuego',
        'leo': 'Fuego',
        'sagitario': 'Fuego',
        'tauro': 'Tierra',
        'virgo': 'Tierra',
        'capricornio': 'Tierra',
        'geminis': 'Aire',
        'libra': 'Aire',
        'acuario': 'Aire',
        'ofiuco': 'Aire',
        'cancer': 'Agua',
        'escorpio': 'Agua',
        'piscis': 'Agua'
    };
    
    // Planetary regents for each sign
    const regentesSignos = {
        'aries': 'Marte',
        'tauro': 'Venus',
        'geminis': 'Mercurio',
        'cancer': 'Luna',
        'leo': 'Sol',
        'virgo': 'Mercurio',
        'libra': 'Venus',
        'escorpio': 'Marte',
        'ofiuco': 'Saturno',
        'sagitario': 'Júpiter',
        'capricornio': 'Sol',
        'acuario': 'Luna',
        'piscis': 'Júpiter'
    };
    
    // For each sign in the sequence, calculate its period
    for (let i = 0; i < secuencia.length; i++) {
        const signo = secuencia[i];
        const anios = DURACION_POR_NIVEL[signo];
        const diasEnPeriodo = anios * DURACIONES.AÑO;
        
        // Calculate start and end date of the period
        const fechaInicio = new Date(fechaNac);
        fechaInicio.setDate(fechaInicio.getDate() + diaActual);
        
        const fechaFin = new Date(fechaInicio);
        fechaFin.setDate(fechaInicio.getDate() + diasEnPeriodo);
        
        // Check if the transit date is within this period
        if (fechaTransito >= fechaInicio && fechaTransito <= fechaFin) {
            // Calculate age for this period
            const edad = calcularEdad(fechaNac, fechaInicio);
            
            // Create main period object
            const periodo = {
                signo: signo,
                nivel: 1,
                fechaInicio: fechaInicio.toLocaleDateString('es-ES'),
                fechaFin: fechaFin.toLocaleDateString('es-ES'),
                edad: edad,
                regente: regentesSignos[signo] || 'Desconocido',
                elemento: elementosSignos[signo] || 'Neutral',
                subperiodos: []
            };
            
            // Calculate subperiods (months)
            const subSecuencia = generarSecuencia(signo);
            let diaInicioSub = diaActual;
            
            for (let j = 0; j < subSecuencia.length; j++) {
                const subSigno = subSecuencia[j];
                const meses = DURACION_POR_NIVEL[subSigno];
                const diasEnSubperiodo = meses * DURACIONES.MES;
                
                // Calculate start and end date of the subperiod
                const fechaInicioSub = new Date(fechaNac);
                fechaInicioSub.setDate(fechaInicioSub.getDate() + diaInicioSub);
                
                const fechaFinSub = new Date(fechaInicioSub);
                fechaFinSub.setDate(fechaInicioSub.getDate() + diasEnSubperiodo);
                
                // Make sure it doesn't exceed the main period end date
                if (fechaFinSub > fechaFin) {
                    fechaFinSub.setTime(fechaFin.getTime());
                }
                
                // Check if the transit date is within this subperiod
                if (fechaTransito >= fechaInicioSub && fechaTransito <= fechaFinSub) {
                    // Calculate age for this subperiod
                    const edadSub = calcularEdad(fechaNac, fechaInicioSub);
                    
                    // Create subperiod object
                    const subperiodo = {
                        signo: subSigno,
                        nivel: 2,
                        fechaInicio: fechaInicioSub.toLocaleDateString('es-ES'),
                        fechaFin: fechaFinSub.toLocaleDateString('es-ES'),
                        edad: edadSub,
                        regente: regentesSignos[subSigno] || 'Desconocido',
                        elemento: elementosSignos[subSigno] || 'Neutral',
                        subperiodos: []
                    };
                    
                    // Calculate sub-subperiods (weeks)
                    const subSubSecuencia = generarSecuencia(subSigno);
                    let diaInicioSubSub = diaInicioSub;
                    
                    for (let k = 0; k < subSubSecuencia.length; k++) {
                        const subSubSigno = subSubSecuencia[k];
                        const semanas = DURACION_POR_NIVEL[subSubSigno];
                        const diasEnSubSubperiodo = semanas * DURACIONES.SEMANA;
                        
                        // Calculate start and end date of the sub-subperiod
                        const fechaInicioSubSub = new Date(fechaNac);
                        fechaInicioSubSub.setDate(fechaInicioSubSub.getDate() + diaInicioSubSub);
                        
                        const fechaFinSubSub = new Date(fechaInicioSubSub);
                        fechaFinSubSub.setDate(fechaInicioSubSub.getDate() + diasEnSubSubperiodo);
                        
                        // Make sure it doesn't exceed the subperiod end date
                        if (fechaFinSubSub > fechaFinSub) {
                            fechaFinSubSub.setTime(fechaFinSub.getTime());
                        }
                        
                        // Check if the transit date is within this sub-subperiod
                        if (fechaTransito >= fechaInicioSubSub && fechaTransito <= fechaFinSubSub) {
                            // Calculate age for this sub-subperiod
                            const edadSubSub = calcularEdad(fechaNac, fechaInicioSubSub);
                            
                            // Create sub-subperiod object
                            const subSubperiodo = {
                                signo: subSubSigno,
                                nivel: 3,
                                fechaInicio: fechaInicioSubSub.toLocaleDateString('es-ES'),
                                fechaFin: fechaFinSubSub.toLocaleDateString('es-ES'),
                                edad: edadSubSub,
                                regente: regentesSignos[subSubSigno] || 'Desconocido',
                                elemento: elementosSignos[subSubSigno] || 'Neutral'
                            };
                            
                            // Add sub-subperiod to the subperiod
                            subperiodo.subperiodos.push(subSubperiodo);
                        }
                        
                        // Advance the start day for the next sub-subperiod
                        diaInicioSubSub += diasEnSubSubperiodo;
                        
                        // If we've passed the end of the subperiod, exit the loop
                        if (diaInicioSubSub >= diaInicioSub + diasEnSubperiodo || 
                            new Date(fechaNac.getTime() + diaInicioSubSub * 24 * 60 * 60 * 1000) > fechaFinSub) {
                            break;
                        }
                    }
                    
                    // Add subperiod to the main period
                    periodo.subperiodos.push(subperiodo);
                }
                
                // Advance the start day for the next subperiod
                diaInicioSub += diasEnSubperiodo;
                
                // If we've passed the end of the main period, exit the loop
                if (diaInicioSub >= diaActual + diasEnPeriodo || 
                    new Date(fechaNac.getTime() + diaInicioSub * 24 * 60 * 60 * 1000) > fechaFin) {
                    break;
                }
            }
            
            // Add the period to the list of active periods
            periodosActivos.push(periodo);
        }
        
        // Advance to the next main period
        diaActual += diasEnPeriodo;
    }
    
    return periodosActivos;
}

// Añadir esta función a tu archivo JavaScript existente
function setupRelevoZodiacalListeners() {
    // Obtener todos los botones de radio para puntos de referencia del Relevo Zodiacal
    const radioButtons = document.querySelectorAll('input[name="puntoReferenciaRelevo"]');
    
    // Añadir event listener a cada botón de radio
    radioButtons.forEach(radio => {
        radio.addEventListener('change', () => {
            // Recalcular Relevo Zodiacal cuando cambia el punto de referencia
            calcularYMostrarRelevoZodiacal();
        });
    });
    
    // Añadir event listener al botón principal de cálculo
    const calculateBtn = document.getElementById('calculateBtn');
    if (calculateBtn) {
        const originalClickHandler = calculateBtn.onclick;
        
        calculateBtn.onclick = function() {
            // Llamar al manejador original si existe
            if (typeof originalClickHandler === 'function') {
                originalClickHandler.call(this);
            } else {
                // Si no hay manejador original, llamar a la función de cálculo directamente
                calculateChart();
            }
            
            // Esperar a que la carta se cargue (usando setTimeout)
            setTimeout(() => {
                calcularYMostrarRelevoZodiacal();
            }, 1000);
        };
    }
    
    // Añadir event listeners a los campos de fecha y tiempo de tránsito
    const transitDateInput = document.getElementById('transitDate');
    const transitTimeInput = document.getElementById('transitTime');
    
    if (transitDateInput) {
        transitDateInput.addEventListener('change', debounce(() => {
            if (document.getElementById('chartContent').style.display !== 'none') {
                calcularYMostrarRelevoZodiacal();
            }
        }, 500));
    }
    
    if (transitTimeInput) {
        transitTimeInput.addEventListener('change', debounce(() => {
            if (document.getElementById('chartContent').style.display !== 'none') {
                calcularYMostrarRelevoZodiacal();
            }
        }, 500));
    }
    
    console.log("Event listeners configurados para Relevo Zodiacal");
}
        
// Nueva función para generar HTML de periodos
function generarHTMLPeriodos(periodos) {
    let html = '';
    
    periodos.forEach(periodo => {
        // Obtener información del elemento del signo
        let elementoInfo = ELEMENTOS_SIGNOS[SIGNOS_NORMALIZADOS[periodo.signo]] || {
            elemento: 'Neutral',
            color: '#f8f9fa',
            borde: '#6c757d',
            className: ''
        };
        
        // Determinar la clase para el elemento
        let elementoClass = elementoInfo.className || periodo.elemento?.toLowerCase() || 'neutral';
        
        html += `
            <div class="relevo-periodo ${elementoClass}">
                <h5>${periodo.signo.charAt(0).toUpperCase() + periodo.signo.slice(1)} - ${periodo.regente}</h5>
                <p>
                    Periodo: ${periodo.fechaInicio} - ${periodo.fechaFin}
                    <br>
                    Edad: ${periodo.edad} años
                </p>
        `;
        
        if (periodo.subperiodos && periodo.subperiodos.length > 0) {
            periodo.subperiodos.forEach(subp => {
                // Obtener clase para subperiodo
                let subElementoInfo = ELEMENTOS_SIGNOS[SIGNOS_NORMALIZADOS[subp.signo]] || {
                    elemento: 'Neutral',
                    color: '#f8f9fa',
                    borde: '#6c757d',
                    className: ''
                };
                
                let subElementoClass = subElementoInfo.className || subp.elemento?.toLowerCase() || 'neutral';
                
                html += `
                    <div class="relevo-subperiodo ${subElementoClass}">
                        <h6>${subp.signo.charAt(0).toUpperCase() + subp.signo.slice(1)} - ${subp.regente}</h6>
                        <p>
                            Subperiodo: ${subp.fechaInicio} - ${subp.fechaFin}
                            <br>
                            Edad: ${subp.edad} años
                        </p>
                `;
                
                if (subp.subperiodos && subp.subperiodos.length > 0) {
                    subp.subperiodos.forEach(subsubp => {
                        // Obtener clase para sub-subperiodo
                        let subsubElementoInfo = ELEMENTOS_SIGNOS[SIGNOS_NORMALIZADOS[subsubp.signo]] || {
                            elemento: 'Neutral',
                            color: '#f8f9fa',
                            borde: '#6c757d',
                            className: ''
                        };
                        
                        let subsubElementoClass = subsubElementoInfo.className || subsubp.elemento?.toLowerCase() || 'neutral';
                        
                        html += `
                            <div class="relevo-subsubperiodo ${subsubElementoClass}">
                                <h6>${subsubp.signo.charAt(0).toUpperCase() + subsubp.signo.slice(1)} - ${subsubp.regente}</h6>
                                <p>
                                    Sub-subperiodo: ${subsubp.fechaInicio} - ${subsubp.fechaFin}
                                    <br>
                                    Edad: ${subsubp.edad} años
                                </p>
                        `;
                        
                        // NUEVO: Añadir un nivel más de sub-sub-subperiodos
                        if (subsubp.subperiodos && subsubp.subperiodos.length > 0) {
                            subsubp.subperiodos.forEach(subsubsubp => {
                                // Obtener clase para sub-sub-subperiodo
                                let subsubsubElementoInfo = ELEMENTOS_SIGNOS[SIGNOS_NORMALIZADOS[subsubsubp.signo]] || {
                                    elemento: 'Neutral',
                                    color: '#f8f9fa',
                                    borde: '#6c757d',
                                    className: ''
                                };
                                
                                let subsubsubElementoClass = subsubsubElementoInfo.className || subsubsubp.elemento?.toLowerCase() || 'neutral';
                                
                                html += `
                                    <div class="relevo-subsubsubperiodo ${subsubsubElementoClass}">
                                        <h6>${subsubsubp.signo.charAt(0).toUpperCase() + subsubsubp.signo.slice(1)} - ${subsubsubp.regente}</h6>
                                        <p>
                                            Sub-sub-subperiodo: ${subsubsubp.fechaInicio} - ${subsubsubp.fechaFin}
                                            <br>
                                            Edad: ${subsubsubp.edad} años
                                        </p>
                                    </div>
                                `;
                            });
                        }
                        html += `</div>`;
                    });
                }
                
                html += `</div>`;
            });
        }
        
        html += `</div>`;
    });
    
    return html;
}
      
        // Función auxiliar para calcular el relevo zodiacal
function calcularRelevoZodiacal(birthDate, ascendente, transitDate) {
    // Convertir fechas a objetos Date
    const fechaNac = new Date(birthDate);
    const fechaTransito = new Date(transitDate);
    
    // Generar secuencia de signos a partir del ascendente
    const secuencia = generarSecuencia(ascendente);
    console.log("Secuencia de signos generada:", secuencia);
    
    // Periodos activos para la fecha de tránsito
    const periodosActivos = [];
    let diaActual = 0;
    
    // Mapeo de elementos para signos
    const elementosSignos = {
        'aries': 'Fuego',
        'leo': 'Fuego',
        'sagitario': 'Fuego',
        'tauro': 'Tierra',
        'virgo': 'Tierra',
        'capricornio': 'Tierra',
        'geminis': 'Aire',
        'libra': 'Aire',
        'acuario': 'Aire',
        'ofiuco': 'Aire',
        'cancer': 'Agua',
        'escorpio': 'Agua',
        'piscis': 'Agua'
    };
    
    // Regentes planetarios para cada signo
    const regentesSignos = {
        'aries': 'Marte',
        'tauro': 'Venus',
        'geminis': 'Mercurio',
        'cancer': 'Luna',
        'leo': 'Sol',
        'virgo': 'Mercurio',
        'libra': 'Venus',
        'escorpio': 'Marte',
        'ofiuco': 'Saturno',
        'sagitario': 'Júpiter',
        'capricornio': 'Sol',
        'acuario': 'Luna',
        'piscis': 'Júpiter'
    };
    
    // Para cada signo en la secuencia, calcular su periodo
    for (let i = 0; i < secuencia.length; i++) {
        const signo = secuencia[i];
        const anios = DURACION_POR_NIVEL[signo];
        const diasEnPeriodo = anios * DURACIONES.AÑO;
        
        // Calcular fecha de inicio y fin del periodo
        const fechaInicio = new Date(fechaNac);
        fechaInicio.setDate(fechaInicio.getDate() + diaActual);
        
        const fechaFin = new Date(fechaInicio);
        fechaFin.setDate(fechaInicio.getDate() + diasEnPeriodo);
        
        // Comprobar si la fecha de tránsito está dentro de este periodo
        if (fechaTransito >= fechaInicio && fechaTransito <= fechaFin) {
            // Calcular edad para este periodo
            const edad = calcularEdad(fechaNac, fechaInicio);
            
            // Crear objeto de periodo principal
            const periodo = {
                signo: signo,
                nivel: 1,
                fechaInicio: fechaInicio.toLocaleDateString('es-ES'),
                fechaFin: fechaFin.toLocaleDateString('es-ES'),
                edad: edad,
                regente: regentesSignos[signo] || 'Desconocido',
                elemento: elementosSignos[signo] || 'Neutral',
                subperiodos: []
            };
            
            // Calcular subperiodos (meses)
            const subSecuencia = generarSecuencia(signo);
            let diaInicioSub = diaActual;
            
            for (let j = 0; j < subSecuencia.length; j++) {
                const subSigno = subSecuencia[j];
                const meses = DURACION_POR_NIVEL[subSigno];
                const diasEnSubperiodo = meses * DURACIONES.MES;
                
                // Calcular fecha de inicio y fin del subperiodo
                const fechaInicioSub = new Date(fechaNac);
                fechaInicioSub.setDate(fechaInicioSub.getDate() + diaInicioSub);
                
                const fechaFinSub = new Date(fechaInicioSub);
                fechaFinSub.setDate(fechaInicioSub.getDate() + diasEnSubperiodo);
                
                // Asegurarse de que no exceda la fecha fin del periodo principal
                if (fechaFinSub > fechaFin) {
                    fechaFinSub.setTime(fechaFin.getTime());
                }
                
                // Comprobar si la fecha de tránsito está dentro de este subperiodo
                if (fechaTransito >= fechaInicioSub && fechaTransito <= fechaFinSub) {
                    // Calcular edad para este subperiodo
                    const edadSub = calcularEdad(fechaNac, fechaInicioSub);
                    
                    // Crear objeto de subperiodo
                    const subperiodo = {
                        signo: subSigno,
                        nivel: 2,
                        fechaInicio: fechaInicioSub.toLocaleDateString('es-ES'),
                        fechaFin: fechaFinSub.toLocaleDateString('es-ES'),
                        edad: edadSub,
                        regente: regentesSignos[subSigno] || 'Desconocido',
                        elemento: elementosSignos[subSigno] || 'Neutral',
                        subperiodos: []
                    };
                    
                    // Calcular sub-subperiodos (semanas)
                    const subSubSecuencia = generarSecuencia(subSigno);
                    let diaInicioSubSub = diaInicioSub;
                    
                    for (let k = 0; k < subSubSecuencia.length; k++) {
                        const subSubSigno = subSubSecuencia[k];
                        const semanas = DURACION_POR_NIVEL[subSubSigno];
                        const diasEnSubSubperiodo = semanas * DURACIONES.SEMANA;
                        
                        // Calcular fecha de inicio y fin del sub-subperiodo
                        const fechaInicioSubSub = new Date(fechaNac);
                        fechaInicioSubSub.setDate(fechaInicioSubSub.getDate() + diaInicioSubSub);
                        
                        const fechaFinSubSub = new Date(fechaInicioSubSub);
                        fechaFinSubSub.setDate(fechaInicioSubSub.getDate() + diasEnSubSubperiodo);
                        
                        // Asegurarse de que no exceda la fecha fin del subperiodo
                        if (fechaFinSubSub > fechaFinSub) {
                            fechaFinSubSub.setTime(fechaFinSub.getTime());
                        }
                        
                        // Comprobar si la fecha de tránsito está dentro de este sub-subperiodo
                        if (fechaTransito >= fechaInicioSubSub && fechaTransito <= fechaFinSubSub) {
                            // Calcular edad para este sub-subperiodo
                            const edadSubSub = calcularEdad(fechaNac, fechaInicioSubSub);
                            
                            // Crear objeto de sub-subperiodo
                            const subSubperiodo = {
                                signo: subSubSigno,
                                nivel: 3,
                                fechaInicio: fechaInicioSubSub.toLocaleDateString('es-ES'),
                                fechaFin: fechaFinSubSub.toLocaleDateString('es-ES'),
                                edad: edadSubSub,
                                regente: regentesSignos[subSubSigno] || 'Desconocido',
                                elemento: elementosSignos[subSubSigno] || 'Neutral',
                                subperiodos: [] // AÑADIDO: Arreglo para subperiodos de nivel 4
                            };
                            
                            // NUEVO: Calcular sub-sub-subperiodos (días)
                            const subSubSubSecuencia = generarSecuencia(subSubSigno);
                            let diaInicioSubSubSub = diaInicioSubSub;
                            
                            for (let l = 0; l < subSubSubSecuencia.length; l++) {
                                const subSubSubSigno = subSubSubSecuencia[l];
                                const dias = DURACION_POR_NIVEL[subSubSubSigno];
                                const diasEnSubSubSubperiodo = dias * DURACIONES.DIA;
                                
                                // Calcular fecha de inicio y fin del sub-sub-subperiodo
                                const fechaInicioSubSubSub = new Date(fechaNac);
                                fechaInicioSubSubSub.setDate(fechaInicioSubSubSub.getDate() + diaInicioSubSubSub);
                                
                                const fechaFinSubSubSub = new Date(fechaInicioSubSubSub);
                                fechaFinSubSubSub.setDate(fechaInicioSubSubSub.getDate() + diasEnSubSubSubperiodo);
                                
                                // Asegurarse de que no exceda la fecha fin del sub-subperiodo
                                if (fechaFinSubSubSub > fechaFinSubSub) {
                                    fechaFinSubSubSub.setTime(fechaFinSubSub.getTime());
                                }
                                
                                // Comprobar si la fecha de tránsito está dentro de este sub-sub-subperiodo
                                if (fechaTransito >= fechaInicioSubSubSub && fechaTransito <= fechaFinSubSubSub) {
                                    // Calcular edad para este sub-sub-subperiodo
                                    const edadSubSubSub = calcularEdad(fechaNac, fechaInicioSubSubSub);
                                    
                                    // Crear objeto de sub-sub-subperiodo
                                    const subSubSubperiodo = {
                                        signo: subSubSubSigno,
                                        nivel: 4,
                                        fechaInicio: fechaInicioSubSubSub.toLocaleDateString('es-ES'),
                                        fechaFin: fechaFinSubSubSub.toLocaleDateString('es-ES'),
                                        edad: edadSubSubSub,
                                        regente: regentesSignos[subSubSubSigno] || 'Desconocido',
                                        elemento: elementosSignos[subSubSubSigno] || 'Neutral'
                                    };
                                    
                                    // Añadir sub-sub-subperiodo al sub-subperiodo
                                    subSubperiodo.subperiodos.push(subSubSubperiodo);
                                }
                                
                                // Avanzar el día de inicio para el siguiente sub-sub-subperiodo
                                diaInicioSubSubSub += diasEnSubSubSubperiodo;
                                
                                // Si hemos sobrepasado el fin del sub-subperiodo, salir del bucle
                                if (diaInicioSubSubSub >= diaInicioSubSub + diasEnSubSubperiodo || 
                                    new Date(fechaNac.getTime() + diaInicioSubSubSub * 24 * 60 * 60 * 1000) > fechaFinSubSub) {
                                    break;
                                }
                            }
                            
                            // Añadir sub-subperiodo al subperiodo
                            subperiodo.subperiodos.push(subSubperiodo);
                        }
                        
                        // Avanzar el día de inicio para el siguiente sub-subperiodo
                        diaInicioSubSub += diasEnSubSubperiodo;
                        
                        // Si hemos sobrepasado el fin del subperiodo, salir del bucle
                        if (diaInicioSubSub >= diaInicioSub + diasEnSubperiodo || 
                            new Date(fechaNac.getTime() + diaInicioSubSub * 24 * 60 * 60 * 1000) > fechaFinSub) {
                            break;
                        }
                    }
                    
                    // Añadir subperiodo al periodo principal
                    periodo.subperiodos.push(subperiodo);
                }
                
                // Avanzar el día de inicio para el siguiente subperiodo
                diaInicioSub += diasEnSubperiodo;
                
                // Si hemos sobrepasado el fin del periodo principal, salir del bucle
                if (diaInicioSub >= diaActual + diasEnPeriodo || 
                    new Date(fechaNac.getTime() + diaInicioSub * 24 * 60 * 60 * 1000) > fechaFin) {
                    break;
                }
            }
            
            // Añadir el periodo a la lista de periodos activos
            periodosActivos.push(periodo);
        }
        
        // Avanzar al siguiente periodo principal
        diaActual += diasEnPeriodo;
    }
    
    return periodosActivos;
}

        // Calcular edad de una persona en una fecha específica
        function calcularEdad(fechaNac, fechaActual) {
            const nac = new Date(fechaNac);
            const actual = new Date(fechaActual);
            let edad = actual.getFullYear() - nac.getFullYear();
            const m = actual.getMonth() - nac.getMonth();
            if (m < 0 || (m === 0 && actual.getDate() < nac.getDate())) edad--;
            return edad;
        }

        // Funciones globales para acceso desde HTML
        window.toggleYearGroup = toggleYearGroup;
        window.showTransitForDate = showTransitForDate;
        window.seleccionarPuntoReferencia = seleccionarPuntoReferencia;
        window.calcularYMostrarRelevoZodiacal = calcularYMostrarRelevoZodiacal;

        function init() {
    console.log("Inicializando aplicación...");
    
    // Establecer fecha y hora actuales
    const now = new Date();
    dateInput.value = now.toISOString().split('T')[0];
    timeInput.value = now.toTimeString().slice(0, 5);
    
    transitDateInput.value = now.toISOString().split('T')[0];
    transitTimeInput.value = now.toTimeString().slice(0, 5);
    
    // Establecer ciudad predeterminada
    cityInput.value = "Bilbao, España";
    transitCityInput.value = "Bilbao, España";
    
    // Event listeners para búsqueda de ciudades
    cityInput.addEventListener('input', debounce(function() {
        handleCitySearch(cityInput.value, false);
    }, 300));
    
    transitCityInput.addEventListener('input', debounce(function() {
        handleCitySearch(transitCityInput.value, true);
    }, 300));
    
    // Event listeners para toggles y botones
    showTransitsToggle.addEventListener('change', toggleTransits);
    calculateBtn.addEventListener('click', function() {
        calculateChart();
        
        // Esperar a que la carta se cargue y luego calcular el Relevo Zodiacal
        setTimeout(() => {
            calcularYMostrarRelevoZodiacal();
        }, 1000);
    });
    
    // Event listeners para filtros de predicciones
    yearFilterSelect.addEventListener('change', renderPredictions);
    tipoPrediccionSelect.addEventListener('change', renderPredictions);
    
    // Configurar inicialmente los controles de tránsitos
    toggleTransits();
    
    // Ocultar loading
    loadingIndicator.style.display = 'none';

    // Configurar event listeners para Relevo Zodiacal
    setupRelevoZodiacalListeners();
    
    console.log("Aplicación inicializada correctamente");
}

// Función para configurar los event listeners del Relevo Zodiacal
function setupRelevoZodiacalListeners() {
    // Obtener todos los botones de radio para puntos de referencia del Relevo Zodiacal
    const radioButtons = document.querySelectorAll('input[name="puntoReferenciaRelevo"]');
    
    // Añadir event listener a cada botón de radio
    radioButtons.forEach(radio => {
        radio.addEventListener('change', () => {
            // Recalcular Relevo Zodiacal cuando cambia el punto de referencia
            calcularYMostrarRelevoZodiacal();
        });
    });
    
    // Añadir event listeners a los campos de fecha y tiempo de tránsito para actualizar el Relevo
    const transitDateInput = document.getElementById('transitDate');
    const transitTimeInput = document.getElementById('transitTime');
    
    if (transitDateInput) {
        transitDateInput.addEventListener('change', debounce(() => {
            if (document.getElementById('chartContent').style.display !== 'none') {
                calcularYMostrarRelevoZodiacal();
            }
        }, 500));
    }
    
    if (transitTimeInput) {
        transitTimeInput.addEventListener('change', debounce(() => {
            if (document.getElementById('chartContent').style.display !== 'none') {
                calcularYMostrarRelevoZodiacal();
            }
        }, 500));
    }
    
    console.log("Event listeners configurados para Relevo Zodiacal");
}
    </script>
</body>
</html>
